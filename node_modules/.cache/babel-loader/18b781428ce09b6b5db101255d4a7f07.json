{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class Pool2DProgram {\n  constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false) {\n    this.variableNames = ['x'];\n\n    if (poolType === 'avg' && computePositions) {\n      throw new Error('Cannot compute positions for average pool.');\n    }\n\n    const filterWidth = convInfo.filterWidth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    this.outputShape = convInfo.outShape;\n    const isAvgPool = poolType === 'avg';\n    const batchFlattenPositionStr = \"((batch  * \".concat(convInfo.inHeight, \" + xR) * \").concat(convInfo.inWidth, \" + xC) * \").concat(convInfo.inChannels, \" + d\");\n    const flattenPositionStr = \"(xR * \".concat(convInfo.inWidth, \" + xC) * \").concat(convInfo.inChannels, \" + d\");\n    let initializationValue = '0.0';\n\n    if (!isAvgPool) {\n      // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n      initializationValue = '-1.0 / 1e-20';\n    }\n\n    if (computePositions) {\n      const compareOp = '>=';\n      this.userCode = \"\\n        const ivec2 strides = ivec2(\".concat(strideHeight, \", \").concat(strideWidth, \");\\n        const ivec2 pads = ivec2(\").concat(padTop, \", \").concat(padLeft, \");\\n\\n        void main() {\\n          ivec4 coords = getOutputCoords();\\n          int batch = coords[0];\\n          int d = coords[3];\\n\\n          ivec2 xRCCorner = coords.yz * strides - pads;\\n          int xRCorner = xRCCorner.x;\\n          int xCCorner = xRCCorner.y;\\n\\n          // max/min x(?, ?, d) to get y(yR, yC, d).\\n          // ? = to be determined\\n          float minMaxValue = 0.0;\\n          float minMaxValueFound = 0.0;\\n          int minMaxPosition = 0;\\n          float avgValue = 0.0;\\n\\n          for (int wR = 0; wR < \").concat(effectiveFilterHeight, \";\\n              wR += \").concat(dilationHeight, \") {\\n            int xR = xRCorner + wR;\\n\\n            if (xR < 0 || xR >= \").concat(convInfo.inHeight, \") {\\n              continue;\\n            }\\n\\n            for (int wC = 0; wC < \").concat(effectiveFilterWidth, \";\\n                wC += \").concat(dilationWidth, \") {\\n              int xC = xCCorner + wC;\\n\\n              if (xC < 0 || xC >= \").concat(convInfo.inWidth, \") {\\n                continue;\\n              }\\n\\n              float value = getX(batch, xR, xC, d);\\n\\n              // If a min / max value has already been found, use it. If not,\\n              // use the current value.\\n              float currMinMaxValue = mix(\\n                  value, minMaxValue, minMaxValueFound);\\n              if (value \").concat(compareOp, \" currMinMaxValue) {\\n                minMaxValue = value;\\n                minMaxValueFound = 1.0;\\n                minMaxPosition = \").concat(flattenPositions ? includeBatchInIndex ? batchFlattenPositionStr : flattenPositionStr : \"wR * \".concat(effectiveFilterWidth, \" + wC\"), \";\\n              }\\n            }\\n          }\\n          setOutput(float(minMaxPosition));\\n        }\\n      \");\n      return;\n    }\n\n    const compareOp = 'max';\n    let returnValue = \"\".concat(poolType, \"(\").concat(poolType, \"(\").concat(poolType, \"(\") + 'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n\n    if (poolType === 'avg') {\n      returnValue = \"avgValue / count\";\n    }\n\n    const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\n    const filterWidthVec4Remainder = filterWidth % 4;\n    const updateSnippet = \"\\n      if (\".concat(isAvgPool, \") {\\n        avgValue += dot(values, ones);\\n      } else {\\n        minMaxValue = \").concat(compareOp, \"(values, minMaxValue);\\n      }\\n    \");\n    this.userCode = \"\\n      const ivec2 strides = ivec2(\".concat(strideHeight, \", \").concat(strideWidth, \");\\n      const ivec2 pads = ivec2(\").concat(padTop, \", \").concat(padLeft, \");\\n      const float initializationValue = \").concat(initializationValue, \";\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float count = 0.0;\\n\\n      float getValue(int batch, int xR, int xC, int d) {\\n        if (xC < 0 || xC >= \").concat(convInfo.inWidth, \") {\\n          return initializationValue;\\n        }\\n        count += 1.0;\\n        return getX(batch, xR, xC, d);\\n      }\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d = coords[3];\\n\\n        ivec2 xRCCorner = coords.yz * strides - pads;\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        // max/min x(?, ?, d) to get y(yR, yC, d).\\n        // ? = to be determined\\n        vec4 minMaxValue = vec4(\").concat(initializationValue, \");\\n        float avgValue = 0.0;\\n        count = 0.0;\\n\\n        for (int wR = 0; wR < \").concat(effectiveFilterHeight, \";\\n            wR += \").concat(dilationHeight, \") {\\n          int xR = xRCorner + wR;\\n\\n          if (xR < 0 || xR >= \").concat(convInfo.inHeight, \") {\\n            continue;\\n          }\\n\\n          for (int wC = 0; wC < \").concat(filterWidthNearestVec4, \"; wC += 4) {\\n            int xC = xCCorner + wC * \").concat(dilationWidth, \";\\n\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + \").concat(dilationWidth, \", d),\\n              getValue(batch, xR, xC + 2 * \").concat(dilationWidth, \", d),\\n              getValue(batch, xR, xC + 3 * \").concat(dilationWidth, \", d)\\n            );\\n\\n            \").concat(updateSnippet, \"\\n          }\\n\\n          int xC = xCCorner + \").concat(filterWidthNearestVec4, \";\\n          if (\").concat(filterWidthVec4Remainder === 1, \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              initializationValue,\\n              initializationValue,\\n              initializationValue\\n            );\\n\\n            \").concat(updateSnippet, \"\\n          } else if (\").concat(filterWidthVec4Remainder === 2, \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + \").concat(dilationWidth, \", d),\\n              initializationValue,\\n              initializationValue\\n            );\\n\\n            \").concat(updateSnippet, \"\\n          } else if (\").concat(filterWidthVec4Remainder === 3, \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + \").concat(dilationWidth, \", d),\\n              getValue(batch, xR, xC + 2 * \").concat(dilationWidth, \", d),\\n              initializationValue\\n            );\\n\\n            \").concat(updateSnippet, \"\\n          }\\n        }\\n        setOutput(\").concat(returnValue, \");\\n      }\\n    \");\n  }\n\n}\nexport class Pool3DProgram {\n  constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false) {\n    this.variableNames = ['x'];\n\n    if (poolType === 'avg' && computePositions) {\n      throw new Error('Cannot compute positions for average pool.');\n    }\n\n    const filterWidth = convInfo.filterWidth;\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationDepth = convInfo.dilationDepth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n    const padFront = convInfo.padInfo.front;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    this.outputShape = convInfo.outShape;\n    const isAvgPool = poolType === 'avg';\n    let initializationValue = '0.0';\n\n    if (!isAvgPool) {\n      // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n      initializationValue = '-1.0 / 1e-20';\n    }\n\n    if (computePositions) {\n      const compareOp = '>=';\n      this.userCode = \"\\n        const ivec3 strides =\\n            ivec3(\".concat(strideDepth, \", \").concat(strideHeight, \", \").concat(strideWidth, \");\\n        const ivec3 pads = ivec3(\").concat(padFront, \", \").concat(padTop, \", \").concat(padLeft, \");\\n\\n        void main() {\\n          ivec5 coords = getOutputCoords();\\n          int batch = coords.x;\\n          int ch = coords.u;\\n\\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\\n          int xDCorner = xCorner.x;\\n          int xRCorner = xCorner.y;\\n          int xCCorner = xCorner.z;\\n\\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\\n          // ? = to be determined\\n          float minMaxValue = 0.0;\\n          float minMaxValueFound = 0.0;\\n          int minMaxPosition = 0;\\n\\n          for (int wD = 0; wD < \").concat(effectiveFilterDepth, \";\\n              wD += \").concat(dilationDepth, \") {\\n            int xD = xDCorner + wD;\\n\\n            if (xD < 0 || xD >= \").concat(convInfo.inDepth, \") {\\n              continue;\\n            }\\n\\n            for (int wR = 0; wR < \").concat(effectiveFilterHeight, \";\\n                wR += \").concat(dilationHeight, \") {\\n              int xR = xRCorner + wR;\\n\\n              if (xR < 0 || xR >= \").concat(convInfo.inHeight, \") {\\n                continue;\\n              }\\n\\n              for (int wC = 0; wC < \").concat(effectiveFilterWidth, \";\\n                  wC += \").concat(dilationWidth, \") {\\n                int xC = xCCorner + wC;\\n\\n                if (xC < 0 || xC >= \").concat(convInfo.inWidth, \") {\\n                  continue;\\n                }\\n\\n                float value = getX(batch, xD, xR, xC, ch);\\n\\n                // If a min / max value has already been found, use it. If not,\\n                // use the current value.\\n                float currMinMaxValue = mix(\\n                    value, minMaxValue, minMaxValueFound);\\n                if (value \").concat(compareOp, \" currMinMaxValue) {\\n                  minMaxValue = value;\\n                  minMaxValueFound = 1.0;\\n                  minMaxPosition = \").concat(flattenPositions ? includeBatchInIndex ? \"(((batch * \".concat(convInfo.inDepth, \" + xD) * \").concat(convInfo.inHeight, \" + xR) * \").concat(convInfo.inWidth, \" + xC) * \").concat(convInfo.inChannels, \" + ch\") : \"((xD * \".concat(convInfo.inHeight, \" + xR) * \").concat(convInfo.inWidth, \" + xC) * \").concat(convInfo.inChannels, \" + ch\") : \"wD * \".concat(effectiveFilterHeight, \" * \").concat(effectiveFilterWidth, \" +\\n                      wR * \").concat(effectiveFilterWidth, \" + wC\"), \";\\n                }\\n              }\\n            }\\n          }\\n          setOutput(float(minMaxPosition));\\n        }\\n      \");\n      return;\n    }\n\n    const compareOp = 'max';\n    let returnValue = \"\".concat(poolType, \"(\").concat(poolType, \"(\").concat(poolType, \"(\") + 'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n\n    if (poolType === 'avg') {\n      returnValue = \"avgValue / count\";\n    }\n\n    const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\n    const filterWidthVec4Remainder = filterWidth % 4;\n    const updateSnippet = \"\\n      if (\".concat(isAvgPool, \") {\\n        avgValue += dot(values, ones);\\n      } else {\\n        minMaxValue = \").concat(compareOp, \"(values, minMaxValue);\\n      }\\n    \");\n    this.userCode = \"\\n      const ivec3 strides =\\n        ivec3(\".concat(strideDepth, \", \").concat(strideHeight, \", \").concat(strideWidth, \");\\n      const ivec3 pads = ivec3(\").concat(padFront, \", \").concat(padTop, \", \").concat(padLeft, \");\\n      const float initializationValue = \").concat(initializationValue, \";\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float count = 0.0;\\n\\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\\n        if (xC < 0 || xC >= \").concat(convInfo.inWidth, \") {\\n          return initializationValue;\\n        }\\n        count += 1.0;\\n        return getX(batch, xD, xR, xC, ch);\\n      }\\n\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int batch = coords.x;\\n        int ch = coords.u;\\n\\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\\n        int xDCorner = xCorner.x;\\n        int xRCorner = xCorner.y;\\n        int xCCorner = xCorner.z;\\n\\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\\n        // ? = to be determined\\n        vec4 minMaxValue = vec4(\").concat(initializationValue, \");\\n        float avgValue = 0.0;\\n        count = 0.0;\\n\\n        for (int wD = 0; wD < \").concat(effectiveFilterDepth, \";\\n            wD += \").concat(dilationDepth, \") {\\n          int xD = xDCorner + wD;\\n\\n          if (xD < 0 || xD >= \").concat(convInfo.inDepth, \") {\\n            continue;\\n          }\\n\\n          for (int wR = 0; wR < \").concat(effectiveFilterHeight, \";\\n            wR += \").concat(dilationHeight, \") {\\n            int xR = xRCorner + wR;\\n\\n            if (xR < 0 || xR >= \").concat(convInfo.inHeight, \") {\\n              continue;\\n            }\\n\\n            for (int wC = 0; wC < \").concat(filterWidthNearestVec4, \"; wC += 4) {\\n              int xC = xCCorner + wC * \").concat(dilationWidth, \";\\n\\n              vec4 values = vec4(\\n                getValue(batch, xD, xR, xC, ch),\\n                getValue(batch, xD, xR, xC + \").concat(dilationWidth, \", ch),\\n                getValue(batch, xD, xR, xC + 2 * \").concat(dilationWidth, \", ch),\\n                getValue(batch, xD, xR, xC + 3 * \").concat(dilationWidth, \", ch)\\n              );\\n\\n              \").concat(updateSnippet, \"\\n            }\\n\\n            int xC = xCCorner + \").concat(filterWidthNearestVec4, \";\\n            if (\").concat(filterWidthVec4Remainder === 1, \") {\\n              vec4 values = vec4(\\n                getValue(batch, xD, xR, xC, ch),\\n                initializationValue,\\n                initializationValue,\\n                initializationValue\\n              );\\n\\n              \").concat(updateSnippet, \"\\n            } else if (\").concat(filterWidthVec4Remainder === 2, \") {\\n              vec4 values = vec4(\\n                getValue(batch, xD, xR, xC, ch),\\n                getValue(batch, xD, xR, xC + \").concat(dilationWidth, \", ch),\\n                initializationValue,\\n                initializationValue\\n              );\\n\\n              \").concat(updateSnippet, \"\\n            } else if (\").concat(filterWidthVec4Remainder === 3, \") {\\n              vec4 values = vec4(\\n                getValue(batch, xD, xR, xC, ch),\\n                getValue(batch, xD, xR, xC + \").concat(dilationWidth, \", ch),\\n                getValue(batch, xD, xR, xC + 2 * \").concat(dilationWidth, \", ch),\\n                initializationValue\\n              );\\n\\n              \").concat(updateSnippet, \"\\n            }\\n          }\\n          setOutput(\").concat(returnValue, \");\\n        }\\n      }\\n    \");\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}