{"ast":null,"code":"import { convertToTensor } from '../tensor_util_env';\nimport { cast } from './cast';\nimport { div } from './div';\nimport { Reduction } from './loss_ops_utils';\nimport { mean } from './mean';\nimport { mul } from './mul';\nimport { notEqual } from './not_equal';\nimport { ones } from './ones';\nimport { op } from './operation';\nimport { scalar } from './scalar';\nimport { sum } from './sum';\n/**\n * Computes the weighted loss between two tensors.\n *\n * @param losses Tensor of shape `[batch_size, d1, ... dN]`.\n * @param weights Tensor whose rank is either 0, or the same rank as\n *    `losses`, and must be broadcastable to `losses` (i.e., all\n *    dimensions must be either `1`, or the same as the corresponding\n *    `losses` dimension).\n */\n\n/** @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'} */\n\nfunction computeWeightedLoss_(losses, weights, reduction = Reduction.SUM_BY_NONZERO_WEIGHTS) {\n  const $losses = convertToTensor(losses, 'losses', 'computeWeightedLoss');\n  let $weights = null;\n\n  if (weights != null) {\n    $weights = convertToTensor(weights, 'weights', 'computeWeightedLoss');\n  }\n\n  const weightedLoss = $weights == null ? $losses : mul($losses, $weights);\n\n  if (reduction === Reduction.NONE) {\n    return weightedLoss;\n  }\n\n  if (reduction === Reduction.SUM) {\n    return sum(weightedLoss);\n  }\n\n  if (reduction === Reduction.MEAN) {\n    if ($weights == null) {\n      return mean(weightedLoss);\n    } else {\n      const broadcastFactor = $losses.size / $weights.size;\n      const result = div(sum(weightedLoss), sum($weights));\n      return broadcastFactor > 1 ? div(result, scalar(broadcastFactor)) : result;\n    }\n  }\n\n  if (reduction === Reduction.SUM_BY_NONZERO_WEIGHTS) {\n    if ($weights == null) {\n      return div(sum(weightedLoss), scalar($losses.size));\n    } else {\n      const broadcastedWeights = mul($weights, ones($losses.shape));\n      const numNonZeros = cast(sum(notEqual(broadcastedWeights, scalar(0))), 'float32');\n      return div(sum(weightedLoss), numNonZeros);\n    }\n  }\n\n  throw Error(\"Unknown reduction: \".concat(reduction));\n}\n\nexport const computeWeightedLoss = op({\n  computeWeightedLoss_\n});","map":null,"metadata":{},"sourceType":"module"}