{"ast":null,"code":"import _slicedToArray from \"/home/victor/COVID-19-Coding-Fest/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nexport function getParamValue(paramName, node, tensorMap, context) {\n  const inputParam = node.inputParams[paramName];\n\n  if (inputParam && inputParam.inputIndexStart !== undefined) {\n    const start = inputParam.inputIndexStart;\n    const end = inputParam.inputIndexEnd === 0 ? undefined : inputParam.inputIndexEnd === undefined ? start + 1 : inputParam.inputIndexEnd;\n\n    if (inputParam.type === 'tensor') {\n      return getTensor(node.inputNames[inputParam.inputIndexStart], tensorMap, context);\n    }\n\n    if (inputParam.type === 'tensors') {\n      const inputs = node.inputNames.slice(start, end);\n      return inputs.map(name => getTensor(name, tensorMap, context));\n    }\n\n    const tensor = getTensor(node.inputNames.slice(start)[0], tensorMap, context);\n    const data = tensor.dataSync();\n    return inputParam.type === 'number' ? data[0] : tfc.util.toNestedArray(tensor.shape, data);\n  }\n\n  const attrParam = node.attrParams[paramName];\n  return attrParam && attrParam.value;\n}\n/**\n * Retrieve the tensor based on input name by extracting the node name and\n * output index information.\n * @param name Node input name\n * @param tensorsMap Tensors map keyed by the node\n */\n\nexport function getTensor(name, tensorsMap, context) {\n  const _parseNodeName = parseNodeName(name),\n        _parseNodeName2 = _slicedToArray(_parseNodeName, 2),\n        nodeName = _parseNodeName2[0],\n        index = _parseNodeName2[1];\n\n  const contextId = context.currentContextIds.find(contextId => {\n    return !!tensorsMap[getNodeNameWithContextId(nodeName, contextId)];\n  });\n  return contextId !== undefined ? tensorsMap[getNodeNameWithContextId(nodeName, contextId)][index] : undefined;\n}\n/**\n * Retrieve the tensors based on input name for current context.\n * @param name Node input name\n * @param tensorsMap Tensors map keyed by the node\n */\n\nexport function getTensorsForCurrentContenxt(name, tensorsMap, context) {\n  return tensorsMap[getNodeNameWithContextId(name, context.currentContextId)];\n}\n/**\n * Returns the node name and index from the Node input name.\n * @param inputName The input name of the node, in format of\n * node_name:output_index, i.e. MatMul:0, if the output_index is not set, it is\n * default to 0.\n */\n\nexport function getNodeNameAndIndex(inputName, context) {\n  const _parseNodeName3 = parseNodeName(inputName),\n        _parseNodeName4 = _slicedToArray(_parseNodeName3, 2),\n        nodeName = _parseNodeName4[0],\n        index = _parseNodeName4[1];\n\n  return [getNodeNameWithContextId(nodeName, context && context.currentContextId), index];\n}\n\nfunction getNodeNameWithContextId(name, contextId) {\n  return !!contextId ? \"\".concat(name, \"-\").concat(contextId) : name;\n}\n\nexport function parseNodeName(name) {\n  const parts = name.split(':');\n\n  if (parts.length === 1) {\n    return [name, 0];\n  }\n\n  const nodeName = parts[0];\n  return [nodeName, Number(parts[parts.length - 1])];\n}\nexport function split(arr, size) {\n  const res = [];\n\n  for (let i = 0; i < arr.length; i += size) {\n    res.push(arr.slice(i, i + size));\n  }\n\n  return res;\n}\nexport function getPadding(node, tensorMap, context) {\n  let pad = getParamValue('pad', node, tensorMap, context);\n\n  if (pad === 'explicit') {\n    // This is 1d array, we need to convert it to 2d array\n    pad = getParamValue('explicitPaddings', node, tensorMap, context);\n    const explicitPadding = [[0, 0], [0, 0], [0, 0], [0, 0]];\n\n    for (let i = 0; i < 4; i++) {\n      explicitPadding[i][0] = pad[i * 2];\n      explicitPadding[i][1] = pad[i * 2 + 1];\n    }\n\n    return explicitPadding;\n  }\n\n  return pad;\n}\n/**\n *  Reuse the tensor if it is marked as keep, otherwise clone the tensor to\n *  avoid disposal. This is important for TensorArray and TensorList ops, since\n *  internally they use a tensor as the id for TensorArray and TensorList, and\n * to simplify lookup, they also use Tensor.id as the key to the internal map.\n * These id tensors have been marked as kept in the backend, we need avoid clone\n * them in order to create new Tensor.id.\n * @param tensor\n */\n\nexport function cloneTensor(tensor) {\n  return tensor.kept ? tensor : tfc.clone(tensor);\n}","map":null,"metadata":{},"sourceType":"module"}