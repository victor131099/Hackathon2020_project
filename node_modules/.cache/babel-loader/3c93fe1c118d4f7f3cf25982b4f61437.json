{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { NodeValueImpl } from './custom_op/node_value_impl';\nimport { getRegisteredOp } from './custom_op/register';\nimport * as arithmetic from './executors/arithmetic_executor';\nimport * as basicMath from './executors/basic_math_executor';\nimport * as control from './executors/control_executor';\nimport * as convolution from './executors/convolution_executor';\nimport * as creation from './executors/creation_executor';\nimport * as dynamic from './executors/dynamic_executor';\nimport * as evaluation from './executors/evaluation_executor';\nimport * as graph from './executors/graph_executor';\nimport * as image from './executors/image_executor';\nimport * as logical from './executors/logical_executor';\nimport * as matrices from './executors/matrices_executor';\nimport * as normalization from './executors/normalization_executor';\nimport * as reduction from './executors/reduction_executor';\nimport * as sliceJoin from './executors/slice_join_executor';\nimport * as spectral from './executors/spectral_executor';\nimport * as transformation from './executors/transformation_executor';\n/**\n * Executes the op defined by the node object.\n * @param node\n * @param tensorMap contains tensors for executed nodes and weights\n */\n\nexport function executeOp(node, tensorMap, context) {\n  const value = ((node, tensorMap, context) => {\n    switch (node.category) {\n      case 'arithmetic':\n        return tfc.tidy(() => arithmetic.executeOp(node, tensorMap, context));\n\n      case 'basic_math':\n        return tfc.tidy(() => basicMath.executeOp(node, tensorMap, context));\n\n      case 'control':\n        return control.executeOp(node, tensorMap, context);\n\n      case 'convolution':\n        return tfc.tidy(() => convolution.executeOp(node, tensorMap, context));\n\n      case 'creation':\n        return tfc.tidy(() => creation.executeOp(node, tensorMap, context));\n\n      case 'dynamic':\n        return dynamic.executeOp(node, tensorMap, context);\n\n      case 'evaluation':\n        return tfc.tidy(() => evaluation.executeOp(node, tensorMap, context));\n\n      case 'image':\n        return tfc.tidy(() => image.executeOp(node, tensorMap, context));\n\n      case 'graph':\n        return tfc.tidy(() => graph.executeOp(node, tensorMap, context));\n\n      case 'logical':\n        return tfc.tidy(() => logical.executeOp(node, tensorMap, context));\n\n      case 'matrices':\n        return tfc.tidy(() => matrices.executeOp(node, tensorMap, context));\n\n      case 'normalization':\n        return tfc.tidy(() => normalization.executeOp(node, tensorMap, context));\n\n      case 'reduction':\n        return tfc.tidy(() => reduction.executeOp(node, tensorMap, context));\n\n      case 'slice_join':\n        return tfc.tidy(() => sliceJoin.executeOp(node, tensorMap, context));\n\n      case 'spectral':\n        return tfc.tidy(() => spectral.executeOp(node, tensorMap, context));\n\n      case 'transformation':\n        return tfc.tidy(() => transformation.executeOp(node, tensorMap, context));\n\n      case 'custom':\n        const opMapper = getRegisteredOp(node.op);\n\n        if (opMapper && opMapper.customExecutor) {\n          return opMapper.customExecutor(new NodeValueImpl(node, tensorMap, context));\n        } else {\n          throw TypeError(\"Custom op \".concat(node.op, \" is not registered.\"));\n        }\n\n      default:\n        throw TypeError(\"Unknown op '\".concat(node.op, \"'. File an issue at \") + \"https://github.com/tensorflow/tfjs/issues so we can add it\" + \", or register a custom execution with tf.registerOp()\");\n    }\n  })(node, tensorMap, context);\n\n  if (value instanceof Promise) {\n    return value.then(data => [].concat(data));\n  }\n\n  return [].concat(value);\n}","map":null,"metadata":{},"sourceType":"module"}