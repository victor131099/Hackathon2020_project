{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tfjs_1 = require(\"@tensorflow/tfjs\");\n\nvar fs = require(\"fs\");\n\nvar util_1 = require(\"util\");\n\nvar nodejs_kernel_backend_1 = require(\"./nodejs_kernel_backend\");\n\nvar readFile = util_1.promisify(fs.readFile); // tslint:disable-next-line:no-require-imports\n\nvar messages = require('./proto/api_pb');\n\nvar SAVED_MODEL_FILE_NAME = '/saved_model.pb';\nvar SAVED_MODEL_INIT_OP_KEY = '__saved_model_init_op'; // This map is used to keep track of loaded SavedModel metagraph mapping\n// information. The map key is TFSavedModel id in JavaScript, value is\n// an object of path to the SavedModel, metagraph tags, and loaded Session ID in\n// the c++ bindings. When user loads a SavedModel signature, it will go through\n// entries in this map to find if the corresponding SavedModel session has\n// already been loaded in C++ addon and will reuse it if existing.\n\nvar loadedSavedModelPathMap = new Map(); // The ID of loaded TFSavedModel. This ID is used to keep track of loaded\n// TFSavedModel, so the loaded session in c++ bindings for the corresponding\n// TFSavedModel can be properly reused/disposed.\n\nvar nextTFSavedModelId = 0;\n/**\n * Get a key in an object by its value. This is used to get protobuf enum value\n * from index.\n *\n * @param object\n * @param value\n */\n// tslint:disable-next-line:no-any\n\nfunction getEnumKeyFromValue(object, value) {\n  return Object.keys(object).find(function (key) {\n    return object[key] === value;\n  });\n}\n\nexports.getEnumKeyFromValue = getEnumKeyFromValue;\n/**\n * Read SavedModel proto message from path.\n *\n * @param path Path to SavedModel folder.\n */\n\nfunction readSavedModelProto(path) {\n  return __awaiter(this, void 0, void 0, function () {\n    var modelFile, array;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          // Load the SavedModel pb file and deserialize it into message.\n          try {\n            fs.accessSync(path + SAVED_MODEL_FILE_NAME, fs.constants.R_OK);\n          } catch (error) {\n            throw new Error('There is no saved_model.pb file in the directory: ' + path);\n          }\n\n          return [4\n          /*yield*/\n          , readFile(path + SAVED_MODEL_FILE_NAME)];\n\n        case 1:\n          modelFile = _a.sent();\n          array = new Uint8Array(modelFile);\n          return [2\n          /*return*/\n          , messages.SavedModel.deserializeBinary(array)];\n      }\n    });\n  });\n}\n\nexports.readSavedModelProto = readSavedModelProto;\n/**\n * Inspect the MetaGraphs of the SavedModel from the provided path. This\n * function will return an array of `MetaGraphInfo` objects.\n *\n * @param path Path to SavedModel folder.\n */\n\n/**\n * @doc {heading: 'Models', subheading: 'SavedModel', namespace: 'node'}\n */\n\nfunction getMetaGraphsFromSavedModel(path) {\n  return __awaiter(this, void 0, void 0, function () {\n    var result, modelMessage, metaGraphList, i, metaGraph, tags, signatureDef, signatureDefMap, signatureDefKeys, key, signatureDefEntry, inputsMapMessage, inputsMapKeys, inputs, inputsMapKey, inputTensor, inputTensorInfo, outputsMapMessage, outputsMapKeys, outputs, outputsMapKey, outputTensor, outputTensorInfo;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          result = [];\n          return [4\n          /*yield*/\n          , readSavedModelProto(path)];\n\n        case 1:\n          modelMessage = _a.sent();\n          metaGraphList = modelMessage.getMetaGraphsList();\n\n          for (i = 0; i < metaGraphList.length; i++) {\n            metaGraph = {};\n            tags = metaGraphList[i].getMetaInfoDef().getTagsList();\n            metaGraph.tags = tags;\n            signatureDef = {};\n            signatureDefMap = metaGraphList[i].getSignatureDefMap();\n            signatureDefKeys = signatureDefMap.keys(); // Go through all signatureDefs\n\n            while (true) {\n              key = signatureDefKeys.next();\n\n              if (key.done) {\n                break;\n              } // Skip TensorFlow internal Signature '__saved_model_init_op'.\n\n\n              if (key.value === SAVED_MODEL_INIT_OP_KEY) {\n                continue;\n              }\n\n              signatureDefEntry = signatureDefMap.get(key.value);\n              inputsMapMessage = signatureDefEntry.getInputsMap();\n              inputsMapKeys = inputsMapMessage.keys();\n              inputs = {};\n\n              while (true) {\n                inputsMapKey = inputsMapKeys.next();\n\n                if (inputsMapKey.done) {\n                  break;\n                }\n\n                inputTensor = inputsMapMessage.get(inputsMapKey.value);\n                inputTensorInfo = {};\n                inputTensorInfo.dtype = mapTFDtypeToJSDtype(getEnumKeyFromValue(messages.DataType, inputTensor.getDtype()));\n                inputTensorInfo.name = inputTensor.getName();\n                inputTensorInfo.shape = inputTensor.getTensorShape().getDimList();\n                inputs[inputsMapKey.value] = inputTensorInfo;\n              }\n\n              outputsMapMessage = signatureDefEntry.getOutputsMap();\n              outputsMapKeys = outputsMapMessage.keys();\n              outputs = {};\n\n              while (true) {\n                outputsMapKey = outputsMapKeys.next();\n\n                if (outputsMapKey.done) {\n                  break;\n                }\n\n                outputTensor = outputsMapMessage.get(outputsMapKey.value);\n                outputTensorInfo = {};\n                outputTensorInfo.dtype = mapTFDtypeToJSDtype(getEnumKeyFromValue(messages.DataType, outputTensor.getDtype()));\n                outputTensorInfo.name = outputTensor.getName();\n                outputTensorInfo.shape = outputTensor.getTensorShape().getDimList();\n                outputs[outputsMapKey.value] = outputTensorInfo;\n              }\n\n              signatureDef[key.value] = {\n                inputs: inputs,\n                outputs: outputs\n              };\n            }\n\n            metaGraph.signatureDefs = signatureDef;\n            result.push(metaGraph);\n          }\n\n          return [2\n          /*return*/\n          , result];\n      }\n    });\n  });\n}\n\nexports.getMetaGraphsFromSavedModel = getMetaGraphsFromSavedModel;\n/**\n * Get input and output node names from SavedModel metagraphs info. The\n * input.output node names will be used when executing a SavedModel signature.\n *\n * @param savedModelInfo The MetaGraphInfo array loaded through\n *     getMetaGraphsFromSavedModel().\n * @param tags The tags of the MetaGraph to get input/output node names from.\n * @param signature The signature to get input/output node names from.\n */\n\nfunction getInputAndOutputNodeNameFromMetaGraphInfo(savedModelInfo, tags, signature) {\n  for (var i = 0; i < savedModelInfo.length; i++) {\n    var metaGraphInfo = savedModelInfo[i];\n\n    if (stringArraysHaveSameElements(tags, metaGraphInfo.tags)) {\n      if (metaGraphInfo.signatureDefs[signature] == null) {\n        throw new Error('The SavedModel does not have signature: ' + signature);\n      }\n\n      var inputNodeNames = {};\n      var outputNodeNames = {};\n\n      for (var _i = 0, _a = Object.keys(metaGraphInfo.signatureDefs); _i < _a.length; _i++) {\n        var signatureDef = _a[_i];\n\n        if (signatureDef === signature) {\n          for (var _b = 0, _c = Object.keys(metaGraphInfo.signatureDefs[signature].inputs); _b < _c.length; _b++) {\n            var tensorName = _c[_b];\n            inputNodeNames[tensorName] = metaGraphInfo.signatureDefs[signature].inputs[tensorName].name;\n          }\n\n          for (var _d = 0, _e = Object.keys(metaGraphInfo.signatureDefs[signature].outputs); _d < _e.length; _d++) {\n            var tensorName = _e[_d];\n            outputNodeNames[tensorName] = metaGraphInfo.signatureDefs[signature].outputs[tensorName].name;\n          }\n        }\n      }\n\n      return [inputNodeNames, outputNodeNames];\n    }\n  }\n\n  throw new Error(\"The SavedModel does not have tags: \" + tags);\n}\n\nexports.getInputAndOutputNodeNameFromMetaGraphInfo = getInputAndOutputNodeNameFromMetaGraphInfo;\n/**\n * A `tf.TFSavedModel` is a signature loaded from a SavedModel\n * metagraph, and allows inference execution.\n */\n\n/**\n * @doc {heading: 'Models', subheading: 'SavedModel', namespace: 'node'}\n */\n\nvar TFSavedModel =\n/** @class */\nfunction () {\n  function TFSavedModel(sessionId, jsid, inputNodeNames, outputNodeNames, backend) {\n    this.sessionId = sessionId;\n    this.jsid = jsid;\n    this.inputNodeNames = inputNodeNames;\n    this.outputNodeNames = outputNodeNames;\n    this.backend = backend;\n    this.disposed = false;\n  }\n\n  Object.defineProperty(TFSavedModel.prototype, \"inputs\", {\n    /**\n     * Return the array of input tensor info.\n     */\n\n    /** @doc {heading: 'Models', subheading: 'SavedModel'} */\n    get: function () {\n      throw new Error('SavedModel inputs information is not available yet.');\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TFSavedModel.prototype, \"outputs\", {\n    /**\n     * Return the array of output tensor info.\n     */\n\n    /** @doc {heading: 'Models', subheading: 'SavedModel'} */\n    get: function () {\n      throw new Error('SavedModel outputs information is not available yet.');\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Delete the SavedModel from nodeBackend and delete corresponding session in\n   * the C++ backend if the session is only used by this TFSavedModel.\n   */\n\n  /** @doc {heading: 'Models', subheading: 'SavedModel'} */\n\n  TFSavedModel.prototype.dispose = function () {\n    if (!this.disposed) {\n      this.disposed = true;\n      loadedSavedModelPathMap.delete(this.jsid);\n\n      for (var _i = 0, _a = Array.from(loadedSavedModelPathMap.keys()); _i < _a.length; _i++) {\n        var id = _a[_i];\n        var value = loadedSavedModelPathMap.get(id);\n\n        if (value.sessionId === this.sessionId) {\n          return;\n        }\n      }\n\n      this.backend.deleteSavedModel(this.sessionId);\n    } else {\n      throw new Error('This SavedModel has already been deleted.');\n    }\n  };\n  /**\n   * Execute the inference for the input tensors.\n   *\n   * @param input The input tensors, when there is single input for the model,\n   * inputs param should be a Tensor. For models with multiple inputs, inputs\n   * params should be in either Tensor[] if the input order is fixed, or\n   * otherwise NamedTensorMap format. The keys in the NamedTensorMap are the\n   * name of input tensors in SavedModel signatureDef. It can be found through\n   * `tf.node.getMetaGraphsFromSavedModel()`.\n   *\n   * For batch inference execution, the tensors for each input need to be\n   * concatenated together. For example with mobilenet, the required input shape\n   * is [1, 244, 244, 3], which represents the [batch, height, width, channel].\n   * If we are provide a batched data of 100 images, the input tensor should be\n   * in the shape of [100, 244, 244, 3].\n   *\n   * @param config Prediction configuration for specifying the batch size.\n   *\n   * @returns Inference result tensors. The output would be single Tensor if\n   * model has single output node, otherwise Tensor[] or NamedTensorMap[] will\n   * be returned for model with multiple outputs.\n   */\n\n  /** @doc {heading: 'Models', subheading: 'SavedModel'} */\n\n\n  TFSavedModel.prototype.predict = function (inputs, config) {\n    var _this = this;\n\n    if (this.disposed) {\n      throw new Error('The TFSavedModel has already been deleted!');\n    } else {\n      var inputTensors = [];\n\n      if (inputs instanceof tfjs_1.Tensor) {\n        inputTensors.push(inputs);\n        var result = this.backend.runSavedModel(this.sessionId, inputTensors, Object.values(this.inputNodeNames), Object.values(this.outputNodeNames));\n        return result.length > 1 ? result : result[0];\n      } else if (Array.isArray(inputs)) {\n        inputTensors = inputs;\n        return this.backend.runSavedModel(this.sessionId, inputTensors, Object.values(this.inputNodeNames), Object.values(this.outputNodeNames));\n      } else {\n        var inputTensorNames = Object.keys(this.inputNodeNames);\n        var providedInputNames = Object.keys(inputs);\n\n        if (!stringArraysHaveSameElements(inputTensorNames, providedInputNames)) {\n          throw new Error(\"The model signatureDef input names are \" + inputTensorNames.join() + \", however the provided input names are \" + providedInputNames.join() + \".\");\n        }\n\n        var inputNodeNamesArray = [];\n\n        for (var i = 0; i < inputTensorNames.length; i++) {\n          inputTensors.push(inputs[inputTensorNames[i]]);\n          inputNodeNamesArray.push(this.inputNodeNames[inputTensorNames[i]]);\n        }\n\n        var outputTensorNames = Object.keys(this.outputNodeNames);\n        var outputNodeNamesArray = [];\n\n        for (var i = 0; i < outputTensorNames.length; i++) {\n          outputNodeNamesArray.push(this.outputNodeNames[outputTensorNames[i]]);\n        }\n\n        var outputTensors_1 = this.backend.runSavedModel(this.sessionId, inputTensors, inputNodeNamesArray, outputNodeNamesArray);\n        tfjs_1.util.assert(outputTensors_1.length === outputNodeNamesArray.length, function () {\n          return 'Output tensors do not match output node names, ' + (\"receive \" + outputTensors_1.length + \") output tensors but \") + (\"there are \" + _this.outputNodeNames.length + \" output nodes.\");\n        });\n        var outputMap = {};\n\n        for (var i = 0; i < outputTensorNames.length; i++) {\n          outputMap[outputTensorNames[i]] = outputTensors_1[i];\n        }\n\n        return outputMap;\n      }\n    }\n  };\n  /**\n   * Execute the inference for the input tensors and return activation\n   * values for specified output node names without batching.\n   *\n   * @param input The input tensors, when there is single input for the model,\n   * inputs param should be a Tensor. For models with multiple inputs, inputs\n   * params should be in either Tensor[] if the input order is fixed, or\n   * otherwise NamedTensorMap format.\n   *\n   * @param outputs string|string[]. List of output node names to retrieve\n   * activation from.\n   *\n   * @returns Activation values for the output nodes result tensors. The return\n   * type matches specified parameter outputs type. The output would be single\n   * Tensor if single output is specified, otherwise Tensor[] for multiple\n   * outputs.\n   */\n\n  /** @doc {heading: 'Models', subheading: 'SavedModel'} */\n\n\n  TFSavedModel.prototype.execute = function (inputs, outputs) {\n    throw new Error('execute() of TFSavedModel is not supported yet.');\n  };\n\n  return TFSavedModel;\n}();\n\nexports.TFSavedModel = TFSavedModel;\n/**\n * Load a TensorFlow SavedModel from disk. TensorFlow SavedModel is different\n * from TensorFlow.js model format. A SavedModel is a directory containing\n * serialized signatures and the states needed to run them. The directory has a\n * saved_model.pb (or saved_model.pbtxt) file storing the actual TensorFlow\n * program, or model, and a set of named signatures, each identifying a\n * function. The directory also has a variables directory contains a standard\n * training checkpoint. The directory may also has a assets directory contains\n * files used by the TensorFlow graph, for example text files used to initialize\n * vocabulary tables. These are supported datatypes: float32, int32, complex64,\n * string.For more information, see this guide:\n * https://www.tensorflow.org/guide/saved_model.\n *\n * @param path The path to the SavedModel.\n * @param tags The tags of the MetaGraph to load. The available tags of a\n *     SavedModel can be retrieved through tf.node.getMetaGraphsFromSavedModel()\n *     API. Defaults to ['serve'].\n * @param signature The name of the SignatureDef to load. The available\n *     SignatureDefs of a SavedModel can be retrieved through\n *     tf.node.getMetaGraphsFromSavedModel() API. Defaults to 'serving_default'.\n */\n\n/** @doc {heading: 'Models', subheading: 'SavedModel', namespace: 'node'} */\n\nfunction loadSavedModel(path, tags, signature) {\n  if (tags === void 0) {\n    tags = ['serve'];\n  }\n\n  if (signature === void 0) {\n    signature = 'serving_default';\n  }\n\n  return __awaiter(this, void 0, void 0, function () {\n    var backend, savedModelInfo, _a, inputNodeNames, outputNodeNames, sessionId, _i, _b, id_1, modelInfo, tagsString, id, savedModel;\n\n    return __generator(this, function (_c) {\n      switch (_c.label) {\n        case 0:\n          nodejs_kernel_backend_1.ensureTensorflowBackend();\n          backend = nodejs_kernel_backend_1.nodeBackend();\n          return [4\n          /*yield*/\n          , getMetaGraphsFromSavedModel(path)];\n\n        case 1:\n          savedModelInfo = _c.sent();\n          _a = getInputAndOutputNodeNameFromMetaGraphInfo(savedModelInfo, tags, signature), inputNodeNames = _a[0], outputNodeNames = _a[1];\n\n          for (_i = 0, _b = Array.from(loadedSavedModelPathMap.keys()); _i < _b.length; _i++) {\n            id_1 = _b[_i];\n            modelInfo = loadedSavedModelPathMap.get(id_1);\n\n            if (modelInfo.path === path && stringArraysHaveSameElements(modelInfo.tags, tags)) {\n              sessionId = modelInfo.sessionId;\n            }\n          }\n\n          if (sessionId == null) {\n            tagsString = tags.join(',');\n            sessionId = backend.loadSavedModelMetaGraph(path, tagsString);\n          }\n\n          id = nextTFSavedModelId++;\n          savedModel = new TFSavedModel(sessionId, id, inputNodeNames, outputNodeNames, backend);\n          loadedSavedModelPathMap.set(id, {\n            path: path,\n            tags: tags,\n            sessionId: sessionId\n          });\n          return [2\n          /*return*/\n          , savedModel];\n      }\n    });\n  });\n}\n\nexports.loadSavedModel = loadSavedModel;\n/**\n * Compare if two unsorted arrays of string have the same elements.\n * @param arrayA\n * @param arrayB\n */\n\nfunction stringArraysHaveSameElements(arrayA, arrayB) {\n  if (arrayA.length === arrayB.length && arrayA.sort().join() === arrayB.sort().join()) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction mapTFDtypeToJSDtype(tfDtype) {\n  switch (tfDtype) {\n    case 'DT_FLOAT':\n      return 'float32';\n\n    case 'DT_INT32':\n      return 'int32';\n\n    case 'DT_BOOL':\n      return 'bool';\n\n    case 'DT_COMPLEX64':\n      return 'complex64';\n\n    case 'DT_STRING':\n      return 'string';\n\n    default:\n      throw new Error('Unsupported tensor DataType: ' + tfDtype + ', try to modify the model in python to convert the datatype');\n  }\n}\n\nfunction getNumOfSavedModels() {\n  nodejs_kernel_backend_1.ensureTensorflowBackend();\n  var backend = nodejs_kernel_backend_1.nodeBackend();\n  return backend.getNumOfSavedModels();\n}\n\nexports.getNumOfSavedModels = getNumOfSavedModels;","map":{"version":3,"sources":["/home/victor/COVID-19-Coding-Fest/node_modules/@tensorflow/tfjs-node-gpu/dist/saved_model.js"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__generator","body","_","label","sent","t","trys","ops","f","y","g","verb","Symbol","iterator","n","v","op","TypeError","call","pop","length","push","Object","defineProperty","exports","tfjs_1","require","fs","util_1","nodejs_kernel_backend_1","readFile","promisify","messages","SAVED_MODEL_FILE_NAME","SAVED_MODEL_INIT_OP_KEY","loadedSavedModelPathMap","Map","nextTFSavedModelId","getEnumKeyFromValue","object","keys","find","key","readSavedModelProto","path","modelFile","array","_a","accessSync","constants","R_OK","error","Error","Uint8Array","SavedModel","deserializeBinary","getMetaGraphsFromSavedModel","modelMessage","metaGraphList","i","metaGraph","tags","signatureDef","signatureDefMap","signatureDefKeys","signatureDefEntry","inputsMapMessage","inputsMapKeys","inputs","inputsMapKey","inputTensor","inputTensorInfo","outputsMapMessage","outputsMapKeys","outputs","outputsMapKey","outputTensor","outputTensorInfo","getMetaGraphsList","getMetaInfoDef","getTagsList","getSignatureDefMap","get","getInputsMap","dtype","mapTFDtypeToJSDtype","DataType","getDtype","name","getName","shape","getTensorShape","getDimList","getOutputsMap","signatureDefs","getInputAndOutputNodeNameFromMetaGraphInfo","savedModelInfo","signature","metaGraphInfo","stringArraysHaveSameElements","inputNodeNames","outputNodeNames","_i","_b","_c","tensorName","_d","_e","TFSavedModel","sessionId","jsid","backend","disposed","prototype","enumerable","configurable","dispose","delete","Array","from","id","deleteSavedModel","predict","config","_this","inputTensors","Tensor","runSavedModel","values","isArray","inputTensorNames","providedInputNames","join","inputNodeNamesArray","outputTensorNames","outputNodeNamesArray","outputTensors_1","util","assert","outputMap","execute","loadSavedModel","id_1","modelInfo","tagsString","savedModel","ensureTensorflowBackend","nodeBackend","loadSavedModelMetaGraph","set","arrayA","arrayB","sort","tfDtype","getNumOfSavedModels"],"mappings":"AAAA;AACA;;;;;;;;;;;;;;;;;AAgBA,IAAIA,SAAS,GAAI,QAAQ,KAAKA,SAAd,IAA4B,UAAUC,OAAV,EAAmBC,UAAnB,EAA+BC,CAA/B,EAAkCC,SAAlC,EAA6C;AACrF,SAAO,KAAKD,CAAC,KAAKA,CAAC,GAAGE,OAAT,CAAN,EAAyB,UAAUC,OAAV,EAAmBC,MAAnB,EAA2B;AACvD,aAASC,SAAT,CAAmBC,KAAnB,EAA0B;AAAE,UAAI;AAAEC,QAAAA,IAAI,CAACN,SAAS,CAACO,IAAV,CAAeF,KAAf,CAAD,CAAJ;AAA8B,OAApC,CAAqC,OAAOG,CAAP,EAAU;AAAEL,QAAAA,MAAM,CAACK,CAAD,CAAN;AAAY;AAAE;;AAC3F,aAASC,QAAT,CAAkBJ,KAAlB,EAAyB;AAAE,UAAI;AAAEC,QAAAA,IAAI,CAACN,SAAS,CAAC,OAAD,CAAT,CAAmBK,KAAnB,CAAD,CAAJ;AAAkC,OAAxC,CAAyC,OAAOG,CAAP,EAAU;AAAEL,QAAAA,MAAM,CAACK,CAAD,CAAN;AAAY;AAAE;;AAC9F,aAASF,IAAT,CAAcI,MAAd,EAAsB;AAAEA,MAAAA,MAAM,CAACC,IAAP,GAAcT,OAAO,CAACQ,MAAM,CAACL,KAAR,CAArB,GAAsC,IAAIN,CAAJ,CAAM,UAAUG,OAAV,EAAmB;AAAEA,QAAAA,OAAO,CAACQ,MAAM,CAACL,KAAR,CAAP;AAAwB,OAAnD,EAAqDO,IAArD,CAA0DR,SAA1D,EAAqEK,QAArE,CAAtC;AAAuH;;AAC/IH,IAAAA,IAAI,CAAC,CAACN,SAAS,GAAGA,SAAS,CAACa,KAAV,CAAgBhB,OAAhB,EAAyBC,UAAU,IAAI,EAAvC,CAAb,EAAyDS,IAAzD,EAAD,CAAJ;AACH,GALM,CAAP;AAMH,CAPD;;AAQA,IAAIO,WAAW,GAAI,QAAQ,KAAKA,WAAd,IAA8B,UAAUjB,OAAV,EAAmBkB,IAAnB,EAAyB;AACrE,MAAIC,CAAC,GAAG;AAAEC,IAAAA,KAAK,EAAE,CAAT;AAAYC,IAAAA,IAAI,EAAE,YAAW;AAAE,UAAIC,CAAC,CAAC,CAAD,CAAD,GAAO,CAAX,EAAc,MAAMA,CAAC,CAAC,CAAD,CAAP;AAAY,aAAOA,CAAC,CAAC,CAAD,CAAR;AAAc,KAAvE;AAAyEC,IAAAA,IAAI,EAAE,EAA/E;AAAmFC,IAAAA,GAAG,EAAE;AAAxF,GAAR;AAAA,MAAsGC,CAAtG;AAAA,MAAyGC,CAAzG;AAAA,MAA4GJ,CAA5G;AAAA,MAA+GK,CAA/G;AACA,SAAOA,CAAC,GAAG;AAAEjB,IAAAA,IAAI,EAAEkB,IAAI,CAAC,CAAD,CAAZ;AAAiB,aAASA,IAAI,CAAC,CAAD,CAA9B;AAAmC,cAAUA,IAAI,CAAC,CAAD;AAAjD,GAAJ,EAA4D,OAAOC,MAAP,KAAkB,UAAlB,KAAiCF,CAAC,CAACE,MAAM,CAACC,QAAR,CAAD,GAAqB,YAAW;AAAE,WAAO,IAAP;AAAc,GAAjF,CAA5D,EAAgJH,CAAvJ;;AACA,WAASC,IAAT,CAAcG,CAAd,EAAiB;AAAE,WAAO,UAAUC,CAAV,EAAa;AAAE,aAAOvB,IAAI,CAAC,CAACsB,CAAD,EAAIC,CAAJ,CAAD,CAAX;AAAsB,KAA5C;AAA+C;;AAClE,WAASvB,IAAT,CAAcwB,EAAd,EAAkB;AACd,QAAIR,CAAJ,EAAO,MAAM,IAAIS,SAAJ,CAAc,iCAAd,CAAN;;AACP,WAAOf,CAAP,EAAU,IAAI;AACV,UAAIM,CAAC,GAAG,CAAJ,EAAOC,CAAC,KAAKJ,CAAC,GAAGW,EAAE,CAAC,CAAD,CAAF,GAAQ,CAAR,GAAYP,CAAC,CAAC,QAAD,CAAb,GAA0BO,EAAE,CAAC,CAAD,CAAF,GAAQP,CAAC,CAAC,OAAD,CAAD,KAAe,CAACJ,CAAC,GAAGI,CAAC,CAAC,QAAD,CAAN,KAAqBJ,CAAC,CAACa,IAAF,CAAOT,CAAP,CAArB,EAAgC,CAA/C,CAAR,GAA4DA,CAAC,CAAChB,IAAjG,CAAD,IAA2G,CAAC,CAACY,CAAC,GAAGA,CAAC,CAACa,IAAF,CAAOT,CAAP,EAAUO,EAAE,CAAC,CAAD,CAAZ,CAAL,EAAuBnB,IAA9I,EAAoJ,OAAOQ,CAAP;AACpJ,UAAII,CAAC,GAAG,CAAJ,EAAOJ,CAAX,EAAcW,EAAE,GAAG,CAACA,EAAE,CAAC,CAAD,CAAF,GAAQ,CAAT,EAAYX,CAAC,CAACd,KAAd,CAAL;;AACd,cAAQyB,EAAE,CAAC,CAAD,CAAV;AACI,aAAK,CAAL;AAAQ,aAAK,CAAL;AAAQX,UAAAA,CAAC,GAAGW,EAAJ;AAAQ;;AACxB,aAAK,CAAL;AAAQd,UAAAA,CAAC,CAACC,KAAF;AAAW,iBAAO;AAAEZ,YAAAA,KAAK,EAAEyB,EAAE,CAAC,CAAD,CAAX;AAAgBnB,YAAAA,IAAI,EAAE;AAAtB,WAAP;;AACnB,aAAK,CAAL;AAAQK,UAAAA,CAAC,CAACC,KAAF;AAAWM,UAAAA,CAAC,GAAGO,EAAE,CAAC,CAAD,CAAN;AAAWA,UAAAA,EAAE,GAAG,CAAC,CAAD,CAAL;AAAU;;AACxC,aAAK,CAAL;AAAQA,UAAAA,EAAE,GAAGd,CAAC,CAACK,GAAF,CAAMY,GAAN,EAAL;;AAAkBjB,UAAAA,CAAC,CAACI,IAAF,CAAOa,GAAP;;AAAc;;AACxC;AACI,cAAI,EAAEd,CAAC,GAAGH,CAAC,CAACI,IAAN,EAAYD,CAAC,GAAGA,CAAC,CAACe,MAAF,GAAW,CAAX,IAAgBf,CAAC,CAACA,CAAC,CAACe,MAAF,GAAW,CAAZ,CAAnC,MAAuDJ,EAAE,CAAC,CAAD,CAAF,KAAU,CAAV,IAAeA,EAAE,CAAC,CAAD,CAAF,KAAU,CAAhF,CAAJ,EAAwF;AAAEd,YAAAA,CAAC,GAAG,CAAJ;AAAO;AAAW;;AAC5G,cAAIc,EAAE,CAAC,CAAD,CAAF,KAAU,CAAV,KAAgB,CAACX,CAAD,IAAOW,EAAE,CAAC,CAAD,CAAF,GAAQX,CAAC,CAAC,CAAD,CAAT,IAAgBW,EAAE,CAAC,CAAD,CAAF,GAAQX,CAAC,CAAC,CAAD,CAAhD,CAAJ,EAA2D;AAAEH,YAAAA,CAAC,CAACC,KAAF,GAAUa,EAAE,CAAC,CAAD,CAAZ;AAAiB;AAAQ;;AACtF,cAAIA,EAAE,CAAC,CAAD,CAAF,KAAU,CAAV,IAAed,CAAC,CAACC,KAAF,GAAUE,CAAC,CAAC,CAAD,CAA9B,EAAmC;AAAEH,YAAAA,CAAC,CAACC,KAAF,GAAUE,CAAC,CAAC,CAAD,CAAX;AAAgBA,YAAAA,CAAC,GAAGW,EAAJ;AAAQ;AAAQ;;AACrE,cAAIX,CAAC,IAAIH,CAAC,CAACC,KAAF,GAAUE,CAAC,CAAC,CAAD,CAApB,EAAyB;AAAEH,YAAAA,CAAC,CAACC,KAAF,GAAUE,CAAC,CAAC,CAAD,CAAX;;AAAgBH,YAAAA,CAAC,CAACK,GAAF,CAAMc,IAAN,CAAWL,EAAX;;AAAgB;AAAQ;;AACnE,cAAIX,CAAC,CAAC,CAAD,CAAL,EAAUH,CAAC,CAACK,GAAF,CAAMY,GAAN;;AACVjB,UAAAA,CAAC,CAACI,IAAF,CAAOa,GAAP;;AAAc;AAXtB;;AAaAH,MAAAA,EAAE,GAAGf,IAAI,CAACiB,IAAL,CAAUnC,OAAV,EAAmBmB,CAAnB,CAAL;AACH,KAjBS,CAiBR,OAAOR,CAAP,EAAU;AAAEsB,MAAAA,EAAE,GAAG,CAAC,CAAD,EAAItB,CAAJ,CAAL;AAAae,MAAAA,CAAC,GAAG,CAAJ;AAAQ,KAjBzB,SAiBkC;AAAED,MAAAA,CAAC,GAAGH,CAAC,GAAG,CAAR;AAAY;;AAC1D,QAAIW,EAAE,CAAC,CAAD,CAAF,GAAQ,CAAZ,EAAe,MAAMA,EAAE,CAAC,CAAD,CAAR;AAAa,WAAO;AAAEzB,MAAAA,KAAK,EAAEyB,EAAE,CAAC,CAAD,CAAF,GAAQA,EAAE,CAAC,CAAD,CAAV,GAAgB,KAAK,CAA9B;AAAiCnB,MAAAA,IAAI,EAAE;AAAvC,KAAP;AAC/B;AACJ,CA1BD;;AA2BAyB,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEjC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAIkC,MAAM,GAAGC,OAAO,CAAC,kBAAD,CAApB;;AACA,IAAIC,EAAE,GAAGD,OAAO,CAAC,IAAD,CAAhB;;AACA,IAAIE,MAAM,GAAGF,OAAO,CAAC,MAAD,CAApB;;AACA,IAAIG,uBAAuB,GAAGH,OAAO,CAAC,yBAAD,CAArC;;AACA,IAAII,QAAQ,GAAGF,MAAM,CAACG,SAAP,CAAiBJ,EAAE,CAACG,QAApB,CAAf,C,CACA;;AACA,IAAIE,QAAQ,GAAGN,OAAO,CAAC,gBAAD,CAAtB;;AACA,IAAIO,qBAAqB,GAAG,iBAA5B;AACA,IAAIC,uBAAuB,GAAG,uBAA9B,C,CACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,uBAAuB,GAAG,IAAIC,GAAJ,EAA9B,C,CACA;AACA;AACA;;AACA,IAAIC,kBAAkB,GAAG,CAAzB;AACA;;;;;;;AAOA;;AACA,SAASC,mBAAT,CAA6BC,MAA7B,EAAqChD,KAArC,EAA4C;AACxC,SAAO+B,MAAM,CAACkB,IAAP,CAAYD,MAAZ,EAAoBE,IAApB,CAAyB,UAAUC,GAAV,EAAe;AAAE,WAAOH,MAAM,CAACG,GAAD,CAAN,KAAgBnD,KAAvB;AAA+B,GAAzE,CAAP;AACH;;AACDiC,OAAO,CAACc,mBAAR,GAA8BA,mBAA9B;AACA;;;;;;AAKA,SAASK,mBAAT,CAA6BC,IAA7B,EAAmC;AAC/B,SAAO9D,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,YAAY;AAC/C,QAAI+D,SAAJ,EAAeC,KAAf;AACA,WAAO9C,WAAW,CAAC,IAAD,EAAO,UAAU+C,EAAV,EAAc;AACnC,cAAQA,EAAE,CAAC5C,KAAX;AACI,aAAK,CAAL;AACI;AACA,cAAI;AACAwB,YAAAA,EAAE,CAACqB,UAAH,CAAcJ,IAAI,GAAGX,qBAArB,EAA4CN,EAAE,CAACsB,SAAH,CAAaC,IAAzD;AACH,WAFD,CAGA,OAAOC,KAAP,EAAc;AACV,kBAAM,IAAIC,KAAJ,CAAU,uDAAuDR,IAAjE,CAAN;AACH;;AACD,iBAAO,CAAC;AAAE;AAAH,YAAcd,QAAQ,CAACc,IAAI,GAAGX,qBAAR,CAAtB,CAAP;;AACJ,aAAK,CAAL;AACIY,UAAAA,SAAS,GAAGE,EAAE,CAAC3C,IAAH,EAAZ;AACA0C,UAAAA,KAAK,GAAG,IAAIO,UAAJ,CAAeR,SAAf,CAAR;AACA,iBAAO,CAAC;AAAE;AAAH,YAAeb,QAAQ,CAACsB,UAAT,CAAoBC,iBAApB,CAAsCT,KAAtC,CAAf,CAAP;AAbR;AAeH,KAhBiB,CAAlB;AAiBH,GAnBe,CAAhB;AAoBH;;AACDtB,OAAO,CAACmB,mBAAR,GAA8BA,mBAA9B;AACA;;;;;;;AAMA;;;;AAGA,SAASa,2BAAT,CAAqCZ,IAArC,EAA2C;AACvC,SAAO9D,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,YAAY;AAC/C,QAAIc,MAAJ,EAAY6D,YAAZ,EAA0BC,aAA1B,EAAyCC,CAAzC,EAA4CC,SAA5C,EAAuDC,IAAvD,EAA6DC,YAA7D,EAA2EC,eAA3E,EAA4FC,gBAA5F,EAA8GtB,GAA9G,EAAmHuB,iBAAnH,EAAsIC,gBAAtI,EAAwJC,aAAxJ,EAAuKC,MAAvK,EAA+KC,YAA/K,EAA6LC,WAA7L,EAA0MC,eAA1M,EAA2NC,iBAA3N,EAA8OC,cAA9O,EAA8PC,OAA9P,EAAuQC,aAAvQ,EAAsRC,YAAtR,EAAoSC,gBAApS;AACA,WAAO7E,WAAW,CAAC,IAAD,EAAO,UAAU+C,EAAV,EAAc;AACnC,cAAQA,EAAE,CAAC5C,KAAX;AACI,aAAK,CAAL;AACIP,UAAAA,MAAM,GAAG,EAAT;AACA,iBAAO,CAAC;AAAE;AAAH,YAAc+C,mBAAmB,CAACC,IAAD,CAAjC,CAAP;;AACJ,aAAK,CAAL;AACIa,UAAAA,YAAY,GAAGV,EAAE,CAAC3C,IAAH,EAAf;AACAsD,UAAAA,aAAa,GAAGD,YAAY,CAACqB,iBAAb,EAAhB;;AACA,eAAKnB,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGD,aAAa,CAACtC,MAA9B,EAAsCuC,CAAC,EAAvC,EAA2C;AACvCC,YAAAA,SAAS,GAAG,EAAZ;AACAC,YAAAA,IAAI,GAAGH,aAAa,CAACC,CAAD,CAAb,CAAiBoB,cAAjB,GAAkCC,WAAlC,EAAP;AACApB,YAAAA,SAAS,CAACC,IAAV,GAAiBA,IAAjB;AACAC,YAAAA,YAAY,GAAG,EAAf;AACAC,YAAAA,eAAe,GAAGL,aAAa,CAACC,CAAD,CAAb,CAAiBsB,kBAAjB,EAAlB;AACAjB,YAAAA,gBAAgB,GAAGD,eAAe,CAACvB,IAAhB,EAAnB,CANuC,CAOvC;;AACA,mBAAO,IAAP,EAAa;AACTE,cAAAA,GAAG,GAAGsB,gBAAgB,CAACvE,IAAjB,EAAN;;AACA,kBAAIiD,GAAG,CAAC7C,IAAR,EAAc;AACV;AACH,eAJQ,CAKT;;;AACA,kBAAI6C,GAAG,CAACnD,KAAJ,KAAc2C,uBAAlB,EAA2C;AACvC;AACH;;AACD+B,cAAAA,iBAAiB,GAAGF,eAAe,CAACmB,GAAhB,CAAoBxC,GAAG,CAACnD,KAAxB,CAApB;AACA2E,cAAAA,gBAAgB,GAAGD,iBAAiB,CAACkB,YAAlB,EAAnB;AACAhB,cAAAA,aAAa,GAAGD,gBAAgB,CAAC1B,IAAjB,EAAhB;AACA4B,cAAAA,MAAM,GAAG,EAAT;;AACA,qBAAO,IAAP,EAAa;AACTC,gBAAAA,YAAY,GAAGF,aAAa,CAAC1E,IAAd,EAAf;;AACA,oBAAI4E,YAAY,CAACxE,IAAjB,EAAuB;AACnB;AACH;;AACDyE,gBAAAA,WAAW,GAAGJ,gBAAgB,CAACgB,GAAjB,CAAqBb,YAAY,CAAC9E,KAAlC,CAAd;AACAgF,gBAAAA,eAAe,GAAG,EAAlB;AACAA,gBAAAA,eAAe,CAACa,KAAhB,GAAwBC,mBAAmB,CAAC/C,mBAAmB,CAACN,QAAQ,CAACsD,QAAV,EAAoBhB,WAAW,CAACiB,QAAZ,EAApB,CAApB,CAA3C;AACAhB,gBAAAA,eAAe,CAACiB,IAAhB,GAAuBlB,WAAW,CAACmB,OAAZ,EAAvB;AACAlB,gBAAAA,eAAe,CAACmB,KAAhB,GAAwBpB,WAAW,CAACqB,cAAZ,GAA6BC,UAA7B,EAAxB;AACAxB,gBAAAA,MAAM,CAACC,YAAY,CAAC9E,KAAd,CAAN,GAA6BgF,eAA7B;AACH;;AACDC,cAAAA,iBAAiB,GAAGP,iBAAiB,CAAC4B,aAAlB,EAApB;AACApB,cAAAA,cAAc,GAAGD,iBAAiB,CAAChC,IAAlB,EAAjB;AACAkC,cAAAA,OAAO,GAAG,EAAV;;AACA,qBAAO,IAAP,EAAa;AACTC,gBAAAA,aAAa,GAAGF,cAAc,CAAChF,IAAf,EAAhB;;AACA,oBAAIkF,aAAa,CAAC9E,IAAlB,EAAwB;AACpB;AACH;;AACD+E,gBAAAA,YAAY,GAAGJ,iBAAiB,CAACU,GAAlB,CAAsBP,aAAa,CAACpF,KAApC,CAAf;AACAsF,gBAAAA,gBAAgB,GAAG,EAAnB;AACAA,gBAAAA,gBAAgB,CAACO,KAAjB,GAAyBC,mBAAmB,CAAC/C,mBAAmB,CAACN,QAAQ,CAACsD,QAAV,EAAoBV,YAAY,CAACW,QAAb,EAApB,CAApB,CAA5C;AACAV,gBAAAA,gBAAgB,CAACW,IAAjB,GAAwBZ,YAAY,CAACa,OAAb,EAAxB;AACAZ,gBAAAA,gBAAgB,CAACa,KAAjB,GAAyBd,YAAY,CAACe,cAAb,GAA8BC,UAA9B,EAAzB;AACAlB,gBAAAA,OAAO,CAACC,aAAa,CAACpF,KAAf,CAAP,GAA+BsF,gBAA/B;AACH;;AACDf,cAAAA,YAAY,CAACpB,GAAG,CAACnD,KAAL,CAAZ,GAA0B;AAAE6E,gBAAAA,MAAM,EAAEA,MAAV;AAAkBM,gBAAAA,OAAO,EAAEA;AAA3B,eAA1B;AACH;;AACDd,YAAAA,SAAS,CAACkC,aAAV,GAA0BhC,YAA1B;AACAlE,YAAAA,MAAM,CAACyB,IAAP,CAAYuC,SAAZ;AACH;;AACD,iBAAO,CAAC;AAAE;AAAH,YAAehE,MAAf,CAAP;AA5DR;AA8DH,KA/DiB,CAAlB;AAgEH,GAlEe,CAAhB;AAmEH;;AACD4B,OAAO,CAACgC,2BAAR,GAAsCA,2BAAtC;AACA;;;;;;;;;;AASA,SAASuC,0CAAT,CAAoDC,cAApD,EAAoEnC,IAApE,EAA0EoC,SAA1E,EAAqF;AACjF,OAAK,IAAItC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqC,cAAc,CAAC5E,MAAnC,EAA2CuC,CAAC,EAA5C,EAAgD;AAC5C,QAAIuC,aAAa,GAAGF,cAAc,CAACrC,CAAD,CAAlC;;AACA,QAAIwC,4BAA4B,CAACtC,IAAD,EAAOqC,aAAa,CAACrC,IAArB,CAAhC,EAA4D;AACxD,UAAIqC,aAAa,CAACJ,aAAd,CAA4BG,SAA5B,KAA0C,IAA9C,EAAoD;AAChD,cAAM,IAAI7C,KAAJ,CAAU,6CAA6C6C,SAAvD,CAAN;AACH;;AACD,UAAIG,cAAc,GAAG,EAArB;AACA,UAAIC,eAAe,GAAG,EAAtB;;AACA,WAAK,IAAIC,EAAE,GAAG,CAAT,EAAYvD,EAAE,GAAGzB,MAAM,CAACkB,IAAP,CAAY0D,aAAa,CAACJ,aAA1B,CAAtB,EAAgEQ,EAAE,GAAGvD,EAAE,CAAC3B,MAAxE,EAAgFkF,EAAE,EAAlF,EAAsF;AAClF,YAAIxC,YAAY,GAAGf,EAAE,CAACuD,EAAD,CAArB;;AACA,YAAIxC,YAAY,KAAKmC,SAArB,EAAgC;AAC5B,eAAK,IAAIM,EAAE,GAAG,CAAT,EAAYC,EAAE,GAAGlF,MAAM,CAACkB,IAAP,CAAY0D,aAAa,CAACJ,aAAd,CAA4BG,SAA5B,EAAuC7B,MAAnD,CAAtB,EAAkFmC,EAAE,GAAGC,EAAE,CAACpF,MAA1F,EAAkGmF,EAAE,EAApG,EAAwG;AACpG,gBAAIE,UAAU,GAAGD,EAAE,CAACD,EAAD,CAAnB;AACAH,YAAAA,cAAc,CAACK,UAAD,CAAd,GACIP,aAAa,CAACJ,aAAd,CAA4BG,SAA5B,EAAuC7B,MAAvC,CAA8CqC,UAA9C,EAA0DjB,IAD9D;AAEH;;AACD,eAAK,IAAIkB,EAAE,GAAG,CAAT,EAAYC,EAAE,GAAGrF,MAAM,CAACkB,IAAP,CAAY0D,aAAa,CAACJ,aAAd,CAA4BG,SAA5B,EAAuCvB,OAAnD,CAAtB,EAAmFgC,EAAE,GAAGC,EAAE,CAACvF,MAA3F,EAAmGsF,EAAE,EAArG,EAAyG;AACrG,gBAAID,UAAU,GAAGE,EAAE,CAACD,EAAD,CAAnB;AACAL,YAAAA,eAAe,CAACI,UAAD,CAAf,GACIP,aAAa,CAACJ,aAAd,CAA4BG,SAA5B,EAAuCvB,OAAvC,CAA+C+B,UAA/C,EAA2DjB,IAD/D;AAEH;AACJ;AACJ;;AACD,aAAO,CAACY,cAAD,EAAiBC,eAAjB,CAAP;AACH;AACJ;;AACD,QAAM,IAAIjD,KAAJ,CAAU,wCAAwCS,IAAlD,CAAN;AACH;;AACDrC,OAAO,CAACuE,0CAAR,GAAqDA,0CAArD;AACA;;;;;AAIA;;;;AAGA,IAAIa,YAAY;AAAG;AAAe,YAAY;AAC1C,WAASA,YAAT,CAAsBC,SAAtB,EAAiCC,IAAjC,EAAuCV,cAAvC,EAAuDC,eAAvD,EAAwEU,OAAxE,EAAiF;AAC7E,SAAKF,SAAL,GAAiBA,SAAjB;AACA,SAAKC,IAAL,GAAYA,IAAZ;AACA,SAAKV,cAAL,GAAsBA,cAAtB;AACA,SAAKC,eAAL,GAAuBA,eAAvB;AACA,SAAKU,OAAL,GAAeA,OAAf;AACA,SAAKC,QAAL,GAAgB,KAAhB;AACH;;AACD1F,EAAAA,MAAM,CAACC,cAAP,CAAsBqF,YAAY,CAACK,SAAnC,EAA8C,QAA9C,EAAwD;AACpD;;;;AAGA;AACA/B,IAAAA,GAAG,EAAE,YAAY;AACb,YAAM,IAAI9B,KAAJ,CAAU,qDAAV,CAAN;AACH,KAPmD;AAQpD8D,IAAAA,UAAU,EAAE,IARwC;AASpDC,IAAAA,YAAY,EAAE;AATsC,GAAxD;AAWA7F,EAAAA,MAAM,CAACC,cAAP,CAAsBqF,YAAY,CAACK,SAAnC,EAA8C,SAA9C,EAAyD;AACrD;;;;AAGA;AACA/B,IAAAA,GAAG,EAAE,YAAY;AACb,YAAM,IAAI9B,KAAJ,CAAU,sDAAV,CAAN;AACH,KAPoD;AAQrD8D,IAAAA,UAAU,EAAE,IARyC;AASrDC,IAAAA,YAAY,EAAE;AATuC,GAAzD;AAWA;;;;;AAIA;;AACAP,EAAAA,YAAY,CAACK,SAAb,CAAuBG,OAAvB,GAAiC,YAAY;AACzC,QAAI,CAAC,KAAKJ,QAAV,EAAoB;AAChB,WAAKA,QAAL,GAAgB,IAAhB;AACA7E,MAAAA,uBAAuB,CAACkF,MAAxB,CAA+B,KAAKP,IAApC;;AACA,WAAK,IAAIR,EAAE,GAAG,CAAT,EAAYvD,EAAE,GAAGuE,KAAK,CAACC,IAAN,CAAWpF,uBAAuB,CAACK,IAAxB,EAAX,CAAtB,EAAkE8D,EAAE,GAAGvD,EAAE,CAAC3B,MAA1E,EAAkFkF,EAAE,EAApF,EAAwF;AACpF,YAAIkB,EAAE,GAAGzE,EAAE,CAACuD,EAAD,CAAX;AACA,YAAI/G,KAAK,GAAG4C,uBAAuB,CAAC+C,GAAxB,CAA4BsC,EAA5B,CAAZ;;AACA,YAAIjI,KAAK,CAACsH,SAAN,KAAoB,KAAKA,SAA7B,EAAwC;AACpC;AACH;AACJ;;AACD,WAAKE,OAAL,CAAaU,gBAAb,CAA8B,KAAKZ,SAAnC;AACH,KAXD,MAYK;AACD,YAAM,IAAIzD,KAAJ,CAAU,2CAAV,CAAN;AACH;AACJ,GAhBD;AAiBA;;;;;;;;;;;;;;;;;;;;;;;AAsBA;;;AACAwD,EAAAA,YAAY,CAACK,SAAb,CAAuBS,OAAvB,GAAiC,UAAUtD,MAAV,EAAkBuD,MAAlB,EAA0B;AACvD,QAAIC,KAAK,GAAG,IAAZ;;AACA,QAAI,KAAKZ,QAAT,EAAmB;AACf,YAAM,IAAI5D,KAAJ,CAAU,4CAAV,CAAN;AACH,KAFD,MAGK;AACD,UAAIyE,YAAY,GAAG,EAAnB;;AACA,UAAIzD,MAAM,YAAY3C,MAAM,CAACqG,MAA7B,EAAqC;AACjCD,QAAAA,YAAY,CAACxG,IAAb,CAAkB+C,MAAlB;AACA,YAAIxE,MAAM,GAAG,KAAKmH,OAAL,CAAagB,aAAb,CAA2B,KAAKlB,SAAhC,EAA2CgB,YAA3C,EAAyDvG,MAAM,CAAC0G,MAAP,CAAc,KAAK5B,cAAnB,CAAzD,EAA6F9E,MAAM,CAAC0G,MAAP,CAAc,KAAK3B,eAAnB,CAA7F,CAAb;AACA,eAAOzG,MAAM,CAACwB,MAAP,GAAgB,CAAhB,GAAoBxB,MAApB,GAA6BA,MAAM,CAAC,CAAD,CAA1C;AACH,OAJD,MAKK,IAAI0H,KAAK,CAACW,OAAN,CAAc7D,MAAd,CAAJ,EAA2B;AAC5ByD,QAAAA,YAAY,GAAGzD,MAAf;AACA,eAAO,KAAK2C,OAAL,CAAagB,aAAb,CAA2B,KAAKlB,SAAhC,EAA2CgB,YAA3C,EAAyDvG,MAAM,CAAC0G,MAAP,CAAc,KAAK5B,cAAnB,CAAzD,EAA6F9E,MAAM,CAAC0G,MAAP,CAAc,KAAK3B,eAAnB,CAA7F,CAAP;AACH,OAHI,MAIA;AACD,YAAI6B,gBAAgB,GAAG5G,MAAM,CAACkB,IAAP,CAAY,KAAK4D,cAAjB,CAAvB;AACA,YAAI+B,kBAAkB,GAAG7G,MAAM,CAACkB,IAAP,CAAY4B,MAAZ,CAAzB;;AACA,YAAI,CAAC+B,4BAA4B,CAAC+B,gBAAD,EAAmBC,kBAAnB,CAAjC,EAAyE;AACrE,gBAAM,IAAI/E,KAAJ,CAAU,4CAA4C8E,gBAAgB,CAACE,IAAjB,EAA5C,GAAsE,yCAAtE,GAAkHD,kBAAkB,CAACC,IAAnB,EAAlH,GAA8I,GAAxJ,CAAN;AACH;;AACD,YAAIC,mBAAmB,GAAG,EAA1B;;AACA,aAAK,IAAI1E,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGuE,gBAAgB,CAAC9G,MAArC,EAA6CuC,CAAC,EAA9C,EAAkD;AAC9CkE,UAAAA,YAAY,CAACxG,IAAb,CAAkB+C,MAAM,CAAC8D,gBAAgB,CAACvE,CAAD,CAAjB,CAAxB;AACA0E,UAAAA,mBAAmB,CAAChH,IAApB,CAAyB,KAAK+E,cAAL,CAAoB8B,gBAAgB,CAACvE,CAAD,CAApC,CAAzB;AACH;;AACD,YAAI2E,iBAAiB,GAAGhH,MAAM,CAACkB,IAAP,CAAY,KAAK6D,eAAjB,CAAxB;AACA,YAAIkC,oBAAoB,GAAG,EAA3B;;AACA,aAAK,IAAI5E,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2E,iBAAiB,CAAClH,MAAtC,EAA8CuC,CAAC,EAA/C,EAAmD;AAC/C4E,UAAAA,oBAAoB,CAAClH,IAArB,CAA0B,KAAKgF,eAAL,CAAqBiC,iBAAiB,CAAC3E,CAAD,CAAtC,CAA1B;AACH;;AACD,YAAI6E,eAAe,GAAG,KAAKzB,OAAL,CAAagB,aAAb,CAA2B,KAAKlB,SAAhC,EAA2CgB,YAA3C,EAAyDQ,mBAAzD,EAA8EE,oBAA9E,CAAtB;AACA9G,QAAAA,MAAM,CAACgH,IAAP,CAAYC,MAAZ,CAAmBF,eAAe,CAACpH,MAAhB,KAA2BmH,oBAAoB,CAACnH,MAAnE,EAA2E,YAAY;AAAE,iBAAO,qDAC3F,aAAaoH,eAAe,CAACpH,MAA7B,GAAsC,uBADqD,KAE3F,eAAewG,KAAK,CAACvB,eAAN,CAAsBjF,MAArC,GAA8C,gBAF6C,CAAP;AAElB,SAFvE;AAGA,YAAIuH,SAAS,GAAG,EAAhB;;AACA,aAAK,IAAIhF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2E,iBAAiB,CAAClH,MAAtC,EAA8CuC,CAAC,EAA/C,EAAmD;AAC/CgF,UAAAA,SAAS,CAACL,iBAAiB,CAAC3E,CAAD,CAAlB,CAAT,GAAkC6E,eAAe,CAAC7E,CAAD,CAAjD;AACH;;AACD,eAAOgF,SAAP;AACH;AACJ;AACJ,GA3CD;AA4CA;;;;;;;;;;;;;;;;;;AAiBA;;;AACA/B,EAAAA,YAAY,CAACK,SAAb,CAAuB2B,OAAvB,GAAiC,UAAUxE,MAAV,EAAkBM,OAAlB,EAA2B;AACxD,UAAM,IAAItB,KAAJ,CAAU,iDAAV,CAAN;AACH,GAFD;;AAGA,SAAOwD,YAAP;AACH,CA9IiC,EAAlC;;AA+IApF,OAAO,CAACoF,YAAR,GAAuBA,YAAvB;AACA;;;;;;;;;;;;;;;;;;;;;;AAqBA;;AACA,SAASiC,cAAT,CAAwBjG,IAAxB,EAA8BiB,IAA9B,EAAoCoC,SAApC,EAA+C;AAC3C,MAAIpC,IAAI,KAAK,KAAK,CAAlB,EAAqB;AAAEA,IAAAA,IAAI,GAAG,CAAC,OAAD,CAAP;AAAmB;;AAC1C,MAAIoC,SAAS,KAAK,KAAK,CAAvB,EAA0B;AAAEA,IAAAA,SAAS,GAAG,iBAAZ;AAAgC;;AAC5D,SAAOnH,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,YAAY;AAC/C,QAAIiI,OAAJ,EAAaf,cAAb,EAA6BjD,EAA7B,EAAiCqD,cAAjC,EAAiDC,eAAjD,EAAkEQ,SAAlE,EAA6EP,EAA7E,EAAiFC,EAAjF,EAAqFuC,IAArF,EAA2FC,SAA3F,EAAsGC,UAAtG,EAAkHxB,EAAlH,EAAsHyB,UAAtH;;AACA,WAAOjJ,WAAW,CAAC,IAAD,EAAO,UAAUwG,EAAV,EAAc;AACnC,cAAQA,EAAE,CAACrG,KAAX;AACI,aAAK,CAAL;AACI0B,UAAAA,uBAAuB,CAACqH,uBAAxB;AACAnC,UAAAA,OAAO,GAAGlF,uBAAuB,CAACsH,WAAxB,EAAV;AACA,iBAAO,CAAC;AAAE;AAAH,YAAc3F,2BAA2B,CAACZ,IAAD,CAAzC,CAAP;;AACJ,aAAK,CAAL;AACIoD,UAAAA,cAAc,GAAGQ,EAAE,CAACpG,IAAH,EAAjB;AACA2C,UAAAA,EAAE,GAAGgD,0CAA0C,CAACC,cAAD,EAAiBnC,IAAjB,EAAuBoC,SAAvB,CAA/C,EAAkFG,cAAc,GAAGrD,EAAE,CAAC,CAAD,CAArG,EAA0GsD,eAAe,GAAGtD,EAAE,CAAC,CAAD,CAA9H;;AACA,eAAKuD,EAAE,GAAG,CAAL,EAAQC,EAAE,GAAGe,KAAK,CAACC,IAAN,CAAWpF,uBAAuB,CAACK,IAAxB,EAAX,CAAlB,EAA8D8D,EAAE,GAAGC,EAAE,CAACnF,MAAtE,EAA8EkF,EAAE,EAAhF,EAAoF;AAChFwC,YAAAA,IAAI,GAAGvC,EAAE,CAACD,EAAD,CAAT;AACAyC,YAAAA,SAAS,GAAG5G,uBAAuB,CAAC+C,GAAxB,CAA4B4D,IAA5B,CAAZ;;AACA,gBAAIC,SAAS,CAACnG,IAAV,KAAmBA,IAAnB,IACAuD,4BAA4B,CAAC4C,SAAS,CAAClF,IAAX,EAAiBA,IAAjB,CADhC,EACwD;AACpDgD,cAAAA,SAAS,GAAGkC,SAAS,CAAClC,SAAtB;AACH;AACJ;;AACD,cAAIA,SAAS,IAAI,IAAjB,EAAuB;AACnBmC,YAAAA,UAAU,GAAGnF,IAAI,CAACuE,IAAL,CAAU,GAAV,CAAb;AACAvB,YAAAA,SAAS,GAAGE,OAAO,CAACqC,uBAAR,CAAgCxG,IAAhC,EAAsCoG,UAAtC,CAAZ;AACH;;AACDxB,UAAAA,EAAE,GAAGnF,kBAAkB,EAAvB;AACA4G,UAAAA,UAAU,GAAG,IAAIrC,YAAJ,CAAiBC,SAAjB,EAA4BW,EAA5B,EAAgCpB,cAAhC,EAAgDC,eAAhD,EAAiEU,OAAjE,CAAb;AACA5E,UAAAA,uBAAuB,CAACkH,GAAxB,CAA4B7B,EAA5B,EAAgC;AAAE5E,YAAAA,IAAI,EAAEA,IAAR;AAAciB,YAAAA,IAAI,EAAEA,IAApB;AAA0BgD,YAAAA,SAAS,EAAEA;AAArC,WAAhC;AACA,iBAAO,CAAC;AAAE;AAAH,YAAeoC,UAAf,CAAP;AAvBR;AAyBH,KA1BiB,CAAlB;AA2BH,GA7Be,CAAhB;AA8BH;;AACDzH,OAAO,CAACqH,cAAR,GAAyBA,cAAzB;AACA;;;;;;AAKA,SAAS1C,4BAAT,CAAsCmD,MAAtC,EAA8CC,MAA9C,EAAsD;AAClD,MAAID,MAAM,CAAClI,MAAP,KAAkBmI,MAAM,CAACnI,MAAzB,IACAkI,MAAM,CAACE,IAAP,GAAcpB,IAAd,OAAyBmB,MAAM,CAACC,IAAP,GAAcpB,IAAd,EAD7B,EACmD;AAC/C,WAAO,IAAP;AACH;;AACD,SAAO,KAAP;AACH;;AACD,SAAS/C,mBAAT,CAA6BoE,OAA7B,EAAsC;AAClC,UAAQA,OAAR;AACI,SAAK,UAAL;AACI,aAAO,SAAP;;AACJ,SAAK,UAAL;AACI,aAAO,OAAP;;AACJ,SAAK,SAAL;AACI,aAAO,MAAP;;AACJ,SAAK,cAAL;AACI,aAAO,WAAP;;AACJ,SAAK,WAAL;AACI,aAAO,QAAP;;AACJ;AACI,YAAM,IAAIrG,KAAJ,CAAU,kCAAkCqG,OAAlC,GACZ,6DADE,CAAN;AAZR;AAeH;;AACD,SAASC,mBAAT,GAA+B;AAC3B7H,EAAAA,uBAAuB,CAACqH,uBAAxB;AACA,MAAInC,OAAO,GAAGlF,uBAAuB,CAACsH,WAAxB,EAAd;AACA,SAAOpC,OAAO,CAAC2C,mBAAR,EAAP;AACH;;AACDlI,OAAO,CAACkI,mBAAR,GAA8BA,mBAA9B","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tfjs_1 = require(\"@tensorflow/tfjs\");\nvar fs = require(\"fs\");\nvar util_1 = require(\"util\");\nvar nodejs_kernel_backend_1 = require(\"./nodejs_kernel_backend\");\nvar readFile = util_1.promisify(fs.readFile);\n// tslint:disable-next-line:no-require-imports\nvar messages = require('./proto/api_pb');\nvar SAVED_MODEL_FILE_NAME = '/saved_model.pb';\nvar SAVED_MODEL_INIT_OP_KEY = '__saved_model_init_op';\n// This map is used to keep track of loaded SavedModel metagraph mapping\n// information. The map key is TFSavedModel id in JavaScript, value is\n// an object of path to the SavedModel, metagraph tags, and loaded Session ID in\n// the c++ bindings. When user loads a SavedModel signature, it will go through\n// entries in this map to find if the corresponding SavedModel session has\n// already been loaded in C++ addon and will reuse it if existing.\nvar loadedSavedModelPathMap = new Map();\n// The ID of loaded TFSavedModel. This ID is used to keep track of loaded\n// TFSavedModel, so the loaded session in c++ bindings for the corresponding\n// TFSavedModel can be properly reused/disposed.\nvar nextTFSavedModelId = 0;\n/**\n * Get a key in an object by its value. This is used to get protobuf enum value\n * from index.\n *\n * @param object\n * @param value\n */\n// tslint:disable-next-line:no-any\nfunction getEnumKeyFromValue(object, value) {\n    return Object.keys(object).find(function (key) { return object[key] === value; });\n}\nexports.getEnumKeyFromValue = getEnumKeyFromValue;\n/**\n * Read SavedModel proto message from path.\n *\n * @param path Path to SavedModel folder.\n */\nfunction readSavedModelProto(path) {\n    return __awaiter(this, void 0, void 0, function () {\n        var modelFile, array;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    // Load the SavedModel pb file and deserialize it into message.\n                    try {\n                        fs.accessSync(path + SAVED_MODEL_FILE_NAME, fs.constants.R_OK);\n                    }\n                    catch (error) {\n                        throw new Error('There is no saved_model.pb file in the directory: ' + path);\n                    }\n                    return [4 /*yield*/, readFile(path + SAVED_MODEL_FILE_NAME)];\n                case 1:\n                    modelFile = _a.sent();\n                    array = new Uint8Array(modelFile);\n                    return [2 /*return*/, messages.SavedModel.deserializeBinary(array)];\n            }\n        });\n    });\n}\nexports.readSavedModelProto = readSavedModelProto;\n/**\n * Inspect the MetaGraphs of the SavedModel from the provided path. This\n * function will return an array of `MetaGraphInfo` objects.\n *\n * @param path Path to SavedModel folder.\n */\n/**\n * @doc {heading: 'Models', subheading: 'SavedModel', namespace: 'node'}\n */\nfunction getMetaGraphsFromSavedModel(path) {\n    return __awaiter(this, void 0, void 0, function () {\n        var result, modelMessage, metaGraphList, i, metaGraph, tags, signatureDef, signatureDefMap, signatureDefKeys, key, signatureDefEntry, inputsMapMessage, inputsMapKeys, inputs, inputsMapKey, inputTensor, inputTensorInfo, outputsMapMessage, outputsMapKeys, outputs, outputsMapKey, outputTensor, outputTensorInfo;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    result = [];\n                    return [4 /*yield*/, readSavedModelProto(path)];\n                case 1:\n                    modelMessage = _a.sent();\n                    metaGraphList = modelMessage.getMetaGraphsList();\n                    for (i = 0; i < metaGraphList.length; i++) {\n                        metaGraph = {};\n                        tags = metaGraphList[i].getMetaInfoDef().getTagsList();\n                        metaGraph.tags = tags;\n                        signatureDef = {};\n                        signatureDefMap = metaGraphList[i].getSignatureDefMap();\n                        signatureDefKeys = signatureDefMap.keys();\n                        // Go through all signatureDefs\n                        while (true) {\n                            key = signatureDefKeys.next();\n                            if (key.done) {\n                                break;\n                            }\n                            // Skip TensorFlow internal Signature '__saved_model_init_op'.\n                            if (key.value === SAVED_MODEL_INIT_OP_KEY) {\n                                continue;\n                            }\n                            signatureDefEntry = signatureDefMap.get(key.value);\n                            inputsMapMessage = signatureDefEntry.getInputsMap();\n                            inputsMapKeys = inputsMapMessage.keys();\n                            inputs = {};\n                            while (true) {\n                                inputsMapKey = inputsMapKeys.next();\n                                if (inputsMapKey.done) {\n                                    break;\n                                }\n                                inputTensor = inputsMapMessage.get(inputsMapKey.value);\n                                inputTensorInfo = {};\n                                inputTensorInfo.dtype = mapTFDtypeToJSDtype(getEnumKeyFromValue(messages.DataType, inputTensor.getDtype()));\n                                inputTensorInfo.name = inputTensor.getName();\n                                inputTensorInfo.shape = inputTensor.getTensorShape().getDimList();\n                                inputs[inputsMapKey.value] = inputTensorInfo;\n                            }\n                            outputsMapMessage = signatureDefEntry.getOutputsMap();\n                            outputsMapKeys = outputsMapMessage.keys();\n                            outputs = {};\n                            while (true) {\n                                outputsMapKey = outputsMapKeys.next();\n                                if (outputsMapKey.done) {\n                                    break;\n                                }\n                                outputTensor = outputsMapMessage.get(outputsMapKey.value);\n                                outputTensorInfo = {};\n                                outputTensorInfo.dtype = mapTFDtypeToJSDtype(getEnumKeyFromValue(messages.DataType, outputTensor.getDtype()));\n                                outputTensorInfo.name = outputTensor.getName();\n                                outputTensorInfo.shape = outputTensor.getTensorShape().getDimList();\n                                outputs[outputsMapKey.value] = outputTensorInfo;\n                            }\n                            signatureDef[key.value] = { inputs: inputs, outputs: outputs };\n                        }\n                        metaGraph.signatureDefs = signatureDef;\n                        result.push(metaGraph);\n                    }\n                    return [2 /*return*/, result];\n            }\n        });\n    });\n}\nexports.getMetaGraphsFromSavedModel = getMetaGraphsFromSavedModel;\n/**\n * Get input and output node names from SavedModel metagraphs info. The\n * input.output node names will be used when executing a SavedModel signature.\n *\n * @param savedModelInfo The MetaGraphInfo array loaded through\n *     getMetaGraphsFromSavedModel().\n * @param tags The tags of the MetaGraph to get input/output node names from.\n * @param signature The signature to get input/output node names from.\n */\nfunction getInputAndOutputNodeNameFromMetaGraphInfo(savedModelInfo, tags, signature) {\n    for (var i = 0; i < savedModelInfo.length; i++) {\n        var metaGraphInfo = savedModelInfo[i];\n        if (stringArraysHaveSameElements(tags, metaGraphInfo.tags)) {\n            if (metaGraphInfo.signatureDefs[signature] == null) {\n                throw new Error('The SavedModel does not have signature: ' + signature);\n            }\n            var inputNodeNames = {};\n            var outputNodeNames = {};\n            for (var _i = 0, _a = Object.keys(metaGraphInfo.signatureDefs); _i < _a.length; _i++) {\n                var signatureDef = _a[_i];\n                if (signatureDef === signature) {\n                    for (var _b = 0, _c = Object.keys(metaGraphInfo.signatureDefs[signature].inputs); _b < _c.length; _b++) {\n                        var tensorName = _c[_b];\n                        inputNodeNames[tensorName] =\n                            metaGraphInfo.signatureDefs[signature].inputs[tensorName].name;\n                    }\n                    for (var _d = 0, _e = Object.keys(metaGraphInfo.signatureDefs[signature].outputs); _d < _e.length; _d++) {\n                        var tensorName = _e[_d];\n                        outputNodeNames[tensorName] =\n                            metaGraphInfo.signatureDefs[signature].outputs[tensorName].name;\n                    }\n                }\n            }\n            return [inputNodeNames, outputNodeNames];\n        }\n    }\n    throw new Error(\"The SavedModel does not have tags: \" + tags);\n}\nexports.getInputAndOutputNodeNameFromMetaGraphInfo = getInputAndOutputNodeNameFromMetaGraphInfo;\n/**\n * A `tf.TFSavedModel` is a signature loaded from a SavedModel\n * metagraph, and allows inference execution.\n */\n/**\n * @doc {heading: 'Models', subheading: 'SavedModel', namespace: 'node'}\n */\nvar TFSavedModel = /** @class */ (function () {\n    function TFSavedModel(sessionId, jsid, inputNodeNames, outputNodeNames, backend) {\n        this.sessionId = sessionId;\n        this.jsid = jsid;\n        this.inputNodeNames = inputNodeNames;\n        this.outputNodeNames = outputNodeNames;\n        this.backend = backend;\n        this.disposed = false;\n    }\n    Object.defineProperty(TFSavedModel.prototype, \"inputs\", {\n        /**\n         * Return the array of input tensor info.\n         */\n        /** @doc {heading: 'Models', subheading: 'SavedModel'} */\n        get: function () {\n            throw new Error('SavedModel inputs information is not available yet.');\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TFSavedModel.prototype, \"outputs\", {\n        /**\n         * Return the array of output tensor info.\n         */\n        /** @doc {heading: 'Models', subheading: 'SavedModel'} */\n        get: function () {\n            throw new Error('SavedModel outputs information is not available yet.');\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Delete the SavedModel from nodeBackend and delete corresponding session in\n     * the C++ backend if the session is only used by this TFSavedModel.\n     */\n    /** @doc {heading: 'Models', subheading: 'SavedModel'} */\n    TFSavedModel.prototype.dispose = function () {\n        if (!this.disposed) {\n            this.disposed = true;\n            loadedSavedModelPathMap.delete(this.jsid);\n            for (var _i = 0, _a = Array.from(loadedSavedModelPathMap.keys()); _i < _a.length; _i++) {\n                var id = _a[_i];\n                var value = loadedSavedModelPathMap.get(id);\n                if (value.sessionId === this.sessionId) {\n                    return;\n                }\n            }\n            this.backend.deleteSavedModel(this.sessionId);\n        }\n        else {\n            throw new Error('This SavedModel has already been deleted.');\n        }\n    };\n    /**\n     * Execute the inference for the input tensors.\n     *\n     * @param input The input tensors, when there is single input for the model,\n     * inputs param should be a Tensor. For models with multiple inputs, inputs\n     * params should be in either Tensor[] if the input order is fixed, or\n     * otherwise NamedTensorMap format. The keys in the NamedTensorMap are the\n     * name of input tensors in SavedModel signatureDef. It can be found through\n     * `tf.node.getMetaGraphsFromSavedModel()`.\n     *\n     * For batch inference execution, the tensors for each input need to be\n     * concatenated together. For example with mobilenet, the required input shape\n     * is [1, 244, 244, 3], which represents the [batch, height, width, channel].\n     * If we are provide a batched data of 100 images, the input tensor should be\n     * in the shape of [100, 244, 244, 3].\n     *\n     * @param config Prediction configuration for specifying the batch size.\n     *\n     * @returns Inference result tensors. The output would be single Tensor if\n     * model has single output node, otherwise Tensor[] or NamedTensorMap[] will\n     * be returned for model with multiple outputs.\n     */\n    /** @doc {heading: 'Models', subheading: 'SavedModel'} */\n    TFSavedModel.prototype.predict = function (inputs, config) {\n        var _this = this;\n        if (this.disposed) {\n            throw new Error('The TFSavedModel has already been deleted!');\n        }\n        else {\n            var inputTensors = [];\n            if (inputs instanceof tfjs_1.Tensor) {\n                inputTensors.push(inputs);\n                var result = this.backend.runSavedModel(this.sessionId, inputTensors, Object.values(this.inputNodeNames), Object.values(this.outputNodeNames));\n                return result.length > 1 ? result : result[0];\n            }\n            else if (Array.isArray(inputs)) {\n                inputTensors = inputs;\n                return this.backend.runSavedModel(this.sessionId, inputTensors, Object.values(this.inputNodeNames), Object.values(this.outputNodeNames));\n            }\n            else {\n                var inputTensorNames = Object.keys(this.inputNodeNames);\n                var providedInputNames = Object.keys(inputs);\n                if (!stringArraysHaveSameElements(inputTensorNames, providedInputNames)) {\n                    throw new Error(\"The model signatureDef input names are \" + inputTensorNames.join() + \", however the provided input names are \" + providedInputNames.join() + \".\");\n                }\n                var inputNodeNamesArray = [];\n                for (var i = 0; i < inputTensorNames.length; i++) {\n                    inputTensors.push(inputs[inputTensorNames[i]]);\n                    inputNodeNamesArray.push(this.inputNodeNames[inputTensorNames[i]]);\n                }\n                var outputTensorNames = Object.keys(this.outputNodeNames);\n                var outputNodeNamesArray = [];\n                for (var i = 0; i < outputTensorNames.length; i++) {\n                    outputNodeNamesArray.push(this.outputNodeNames[outputTensorNames[i]]);\n                }\n                var outputTensors_1 = this.backend.runSavedModel(this.sessionId, inputTensors, inputNodeNamesArray, outputNodeNamesArray);\n                tfjs_1.util.assert(outputTensors_1.length === outputNodeNamesArray.length, function () { return 'Output tensors do not match output node names, ' +\n                    (\"receive \" + outputTensors_1.length + \") output tensors but \") +\n                    (\"there are \" + _this.outputNodeNames.length + \" output nodes.\"); });\n                var outputMap = {};\n                for (var i = 0; i < outputTensorNames.length; i++) {\n                    outputMap[outputTensorNames[i]] = outputTensors_1[i];\n                }\n                return outputMap;\n            }\n        }\n    };\n    /**\n     * Execute the inference for the input tensors and return activation\n     * values for specified output node names without batching.\n     *\n     * @param input The input tensors, when there is single input for the model,\n     * inputs param should be a Tensor. For models with multiple inputs, inputs\n     * params should be in either Tensor[] if the input order is fixed, or\n     * otherwise NamedTensorMap format.\n     *\n     * @param outputs string|string[]. List of output node names to retrieve\n     * activation from.\n     *\n     * @returns Activation values for the output nodes result tensors. The return\n     * type matches specified parameter outputs type. The output would be single\n     * Tensor if single output is specified, otherwise Tensor[] for multiple\n     * outputs.\n     */\n    /** @doc {heading: 'Models', subheading: 'SavedModel'} */\n    TFSavedModel.prototype.execute = function (inputs, outputs) {\n        throw new Error('execute() of TFSavedModel is not supported yet.');\n    };\n    return TFSavedModel;\n}());\nexports.TFSavedModel = TFSavedModel;\n/**\n * Load a TensorFlow SavedModel from disk. TensorFlow SavedModel is different\n * from TensorFlow.js model format. A SavedModel is a directory containing\n * serialized signatures and the states needed to run them. The directory has a\n * saved_model.pb (or saved_model.pbtxt) file storing the actual TensorFlow\n * program, or model, and a set of named signatures, each identifying a\n * function. The directory also has a variables directory contains a standard\n * training checkpoint. The directory may also has a assets directory contains\n * files used by the TensorFlow graph, for example text files used to initialize\n * vocabulary tables. These are supported datatypes: float32, int32, complex64,\n * string.For more information, see this guide:\n * https://www.tensorflow.org/guide/saved_model.\n *\n * @param path The path to the SavedModel.\n * @param tags The tags of the MetaGraph to load. The available tags of a\n *     SavedModel can be retrieved through tf.node.getMetaGraphsFromSavedModel()\n *     API. Defaults to ['serve'].\n * @param signature The name of the SignatureDef to load. The available\n *     SignatureDefs of a SavedModel can be retrieved through\n *     tf.node.getMetaGraphsFromSavedModel() API. Defaults to 'serving_default'.\n */\n/** @doc {heading: 'Models', subheading: 'SavedModel', namespace: 'node'} */\nfunction loadSavedModel(path, tags, signature) {\n    if (tags === void 0) { tags = ['serve']; }\n    if (signature === void 0) { signature = 'serving_default'; }\n    return __awaiter(this, void 0, void 0, function () {\n        var backend, savedModelInfo, _a, inputNodeNames, outputNodeNames, sessionId, _i, _b, id_1, modelInfo, tagsString, id, savedModel;\n        return __generator(this, function (_c) {\n            switch (_c.label) {\n                case 0:\n                    nodejs_kernel_backend_1.ensureTensorflowBackend();\n                    backend = nodejs_kernel_backend_1.nodeBackend();\n                    return [4 /*yield*/, getMetaGraphsFromSavedModel(path)];\n                case 1:\n                    savedModelInfo = _c.sent();\n                    _a = getInputAndOutputNodeNameFromMetaGraphInfo(savedModelInfo, tags, signature), inputNodeNames = _a[0], outputNodeNames = _a[1];\n                    for (_i = 0, _b = Array.from(loadedSavedModelPathMap.keys()); _i < _b.length; _i++) {\n                        id_1 = _b[_i];\n                        modelInfo = loadedSavedModelPathMap.get(id_1);\n                        if (modelInfo.path === path &&\n                            stringArraysHaveSameElements(modelInfo.tags, tags)) {\n                            sessionId = modelInfo.sessionId;\n                        }\n                    }\n                    if (sessionId == null) {\n                        tagsString = tags.join(',');\n                        sessionId = backend.loadSavedModelMetaGraph(path, tagsString);\n                    }\n                    id = nextTFSavedModelId++;\n                    savedModel = new TFSavedModel(sessionId, id, inputNodeNames, outputNodeNames, backend);\n                    loadedSavedModelPathMap.set(id, { path: path, tags: tags, sessionId: sessionId });\n                    return [2 /*return*/, savedModel];\n            }\n        });\n    });\n}\nexports.loadSavedModel = loadSavedModel;\n/**\n * Compare if two unsorted arrays of string have the same elements.\n * @param arrayA\n * @param arrayB\n */\nfunction stringArraysHaveSameElements(arrayA, arrayB) {\n    if (arrayA.length === arrayB.length &&\n        arrayA.sort().join() === arrayB.sort().join()) {\n        return true;\n    }\n    return false;\n}\nfunction mapTFDtypeToJSDtype(tfDtype) {\n    switch (tfDtype) {\n        case 'DT_FLOAT':\n            return 'float32';\n        case 'DT_INT32':\n            return 'int32';\n        case 'DT_BOOL':\n            return 'bool';\n        case 'DT_COMPLEX64':\n            return 'complex64';\n        case 'DT_STRING':\n            return 'string';\n        default:\n            throw new Error('Unsupported tensor DataType: ' + tfDtype +\n                ', try to modify the model in python to convert the datatype');\n    }\n}\nfunction getNumOfSavedModels() {\n    nodejs_kernel_backend_1.ensureTensorflowBackend();\n    var backend = nodejs_kernel_backend_1.nodeBackend();\n    return backend.getNumOfSavedModels();\n}\nexports.getNumOfSavedModels = getNumOfSavedModels;\n"]},"metadata":{},"sourceType":"script"}