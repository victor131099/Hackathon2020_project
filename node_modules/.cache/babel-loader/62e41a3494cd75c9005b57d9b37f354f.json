{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { getParamValue } from './utils';\nexport const executeOp = (node, tensorMap, context) => {\n  switch (node.op) {\n    case 'ConcatV2':\n    case 'Concat':\n      {\n        const n = getParamValue('n', node, tensorMap, context);\n        const axis = getParamValue('axis', node, tensorMap, context);\n        let inputs = getParamValue('tensors', node, tensorMap, context);\n        inputs = inputs.slice(0, n);\n        return [tfc.concat(inputs, axis)];\n      }\n\n    case 'GatherV2':\n    case 'Gather':\n      {\n        const axis = getParamValue('axis', node, tensorMap, context);\n        const input = getParamValue('x', node, tensorMap, context);\n        const indices = getParamValue('indices', node, tensorMap, context);\n        return [tfc.gather(input, indices.asType('int32'), axis)];\n      }\n\n    case 'ReverseV2':\n    case 'Reverse':\n      {\n        const axis = getParamValue('axis', node, tensorMap, context);\n        const input = getParamValue('x', node, tensorMap, context);\n        return [tfc.reverse(input, axis)];\n      }\n\n    case 'Slice':\n      {\n        // tslint:disable-next-line:no-any\n        const begin = getParamValue('begin', node, tensorMap, context); // tslint:disable-next-line:no-any\n\n        const size = getParamValue('size', node, tensorMap, context);\n        return [tfc.slice(getParamValue('x', node, tensorMap, context), begin, size)];\n      }\n\n    case 'StridedSlice':\n      {\n        const begin = getParamValue('begin', node, tensorMap, context);\n        const end = getParamValue('end', node, tensorMap, context);\n        const strides = getParamValue('strides', node, tensorMap, context);\n        const beginMask = getParamValue('beginMask', node, tensorMap, context);\n        const endMask = getParamValue('endMask', node, tensorMap, context);\n        const ellipsisMask = getParamValue('ellipsisMask', node, tensorMap, context);\n        const newAxisMask = getParamValue('newAxisMask', node, tensorMap, context);\n        const shrinkAxisMask = getParamValue('shrinkAxisMask', node, tensorMap, context);\n        const tensor = getParamValue('x', node, tensorMap, context);\n        return [tfc.stridedSlice(tensor, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask)];\n      }\n\n    case 'Pack':\n      {\n        return tfc.tidy(() => {\n          const axis = getParamValue('axis', node, tensorMap, context);\n          const tensors = getParamValue('tensors', node, tensorMap, context); // Reshape the tensors to the first tensor's shape if they don't match.\n\n          const shape = tensors[0].shape;\n          const squeezedShape = tensors[0].squeeze().shape;\n          const mapped = tensors.map(tensor => {\n            const sameShape = tfc.util.arraysEqual(tensor.shape, shape);\n\n            if (!sameShape && !tfc.util.arraysEqual(tensor.squeeze().shape, squeezedShape)) {\n              throw new Error('the input tensors shape does not match');\n            }\n\n            return sameShape ? tensor : tensor.reshape(shape);\n          });\n          return [tfc.stack(mapped, axis)];\n        });\n      }\n\n    case 'Unpack':\n      {\n        const axis = getParamValue('axis', node, tensorMap, context);\n        const tensor = getParamValue('tensor', node, tensorMap, context);\n        return tfc.unstack(tensor, axis);\n      }\n\n    case 'Tile':\n      {\n        const reps = getParamValue('reps', node, tensorMap, context);\n        return [tfc.tile(getParamValue('x', node, tensorMap, context), reps)];\n      }\n\n    case 'Split':\n    case 'SplitV':\n      {\n        const axis = getParamValue('axis', node, tensorMap, context);\n        const numOrSizeSplits = getParamValue('numOrSizeSplits', node, tensorMap, context);\n        const tensor = getParamValue('x', node, tensorMap, context);\n        return tfc.split(tensor, numOrSizeSplits, axis);\n      }\n\n    case 'ScatterNd':\n      {\n        const indices = getParamValue('indices', node, tensorMap, context);\n        const values = getParamValue('values', node, tensorMap, context);\n        const shape = getParamValue('shape', node, tensorMap, context);\n        return [tfc.scatterND(indices, values, shape)];\n      }\n\n    case 'GatherNd':\n      {\n        const x = getParamValue('x', node, tensorMap, context);\n        const indices = getParamValue('indices', node, tensorMap, context);\n        return [tfc.gatherND(x, indices)];\n      }\n\n    case 'SparseToDense':\n      {\n        const indices = getParamValue('sparseIndices', node, tensorMap, context);\n        const shape = getParamValue('outputShape', node, tensorMap, context);\n        const sparseValues = getParamValue('sparseValues', node, tensorMap, context);\n        const defaultValue = getParamValue('defaultValue', node, tensorMap, context);\n        return [tfc.sparseToDense(indices, sparseValues, shape, sparseValues.dtype === defaultValue.dtype ? defaultValue : defaultValue.asType(sparseValues.dtype))];\n      }\n\n    default:\n      throw TypeError(\"Node type \".concat(node.op, \" is not implemented\"));\n  }\n};\nexport const CATEGORY = 'slice_join';","map":null,"metadata":{},"sourceType":"module"}