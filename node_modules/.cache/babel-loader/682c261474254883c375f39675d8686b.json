{"ast":null,"code":"/**\n * ExecutionContext captures the runtime environment of the node. It keeps\n * track of the current frame and iteration for the control flow ops.\n *\n * For example, typical Dynamic RNN model may contain loops, for which\n * TensorFlow will generate graphs with Enter/Exit nodes to control the\n * current execution frame, and NextIteration Nodes for iteration id increment.\n * For model with branch logic, TensorFLow will generate Switch/Merge ops.\n */\nexport class ExecutionContext {\n  constructor(weightMap = {}, tensorArrayMap = {}, tensorListMap = {}, functionMap = {}) {\n    this.weightMap = weightMap;\n    this.tensorArrayMap = tensorArrayMap;\n    this.tensorListMap = tensorListMap;\n    this.functionMap = functionMap;\n    this.rootContext = {\n      id: 0,\n      frameName: '',\n      iterationId: 0\n    };\n    this.contexts = [this.rootContext];\n    this.lastId = 0;\n    this.generateCurrentContextIds();\n  }\n\n  newFrame(id, frameName) {\n    return {\n      id,\n      frameName,\n      iterationId: 0\n    };\n  }\n  /**\n   * Set the current context\n   * @param contexts: ExecutionContextInfo[] the current path of execution\n   * frames\n   */\n\n\n  set currentContext(contexts) {\n    if (this.contexts !== contexts) {\n      this.contexts = contexts;\n      this.generateCurrentContextIds();\n    }\n  }\n\n  get currentContext() {\n    return this.contexts;\n  }\n  /**\n   * Returns the current context in string format.\n   */\n\n\n  get currentContextId() {\n    return this._currentContextIds[0];\n  }\n  /**\n   * Returns the current context and all parent contexts in string format.\n   * This allow access to the nodes in the current and parent frames.\n   */\n\n\n  get currentContextIds() {\n    return this._currentContextIds;\n  }\n\n  generateCurrentContextIds() {\n    const names = [];\n\n    for (let i = 0; i < this.contexts.length - 1; i++) {\n      const contexts = this.contexts.slice(0, this.contexts.length - i);\n      names.push(this.contextIdforContexts(contexts));\n    }\n\n    names.push('');\n    this._currentContextIds = names;\n  }\n\n  contextIdforContexts(contexts) {\n    return contexts ? contexts.map(context => context.id === 0 && context.iterationId === 0 ? '' : \"\".concat(context.frameName, \"-\").concat(context.iterationId)).join('/') : '';\n  }\n  /**\n   * Enter a new frame, a new context is pushed on the current context list.\n   * @param frameId new frame id\n   */\n\n\n  enterFrame(frameId) {\n    if (this.contexts) {\n      this.lastId++;\n      this.contexts = this.contexts.slice();\n      this.contexts.push(this.newFrame(this.lastId, frameId));\n\n      this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));\n    }\n  }\n  /**\n   * Exit the current frame, the last context is removed from the current\n   * context list.\n   */\n\n\n  exitFrame() {\n    if (this.contexts && this.contexts.length > 1) {\n      this.contexts = this.contexts.slice();\n      this.contexts.splice(-1);\n      this.currentContextIds.shift();\n    } else {\n      throw new Error('Cannot exit frame, the context is empty');\n    }\n  }\n  /**\n   * Enter the next iteration of a loop, the iteration id of last context is\n   * increased.\n   */\n\n\n  nextIteration() {\n    if (this.contexts && this.contexts.length > 0) {\n      this.contexts = this.contexts.slice();\n      this.lastId++;\n      const context = Object.assign({}, this.contexts[this.contexts.length - 1]);\n      context.iterationId += 1;\n      context.id = this.lastId;\n      this.contexts.splice(-1, 1, context);\n\n      this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));\n    } else {\n      throw new Error('Cannot increase frame iteration, the context is empty');\n    }\n  }\n\n  getWeight(name) {\n    return this.weightMap[name];\n  }\n\n  addTensorArray(tensorArray) {\n    this.tensorArrayMap[tensorArray.id] = tensorArray;\n  }\n\n  getTensorArray(id) {\n    return this.tensorArrayMap[id];\n  }\n\n  addTensorList(tensorList) {\n    this.tensorListMap[tensorList.id] = tensorList;\n  }\n\n  getTensorList(id) {\n    return this.tensorListMap[id];\n  }\n\n  dispose() {\n    for (const key in this.tensorArrayMap) {\n      this.tensorArrayMap[key].clearAndClose();\n    }\n\n    for (const key in this.tensorListMap) {\n      this.tensorListMap[key].clearAndClose();\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}