{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { customGrad } from '../gradients';\nimport { convertToTensor } from '../tensor_util_env';\nimport { parseAxisParam, sizeFromShape } from '../util';\nimport { computeOutAndReduceShapes } from './axis_util';\nimport { cast } from './cast';\nimport { div } from './div';\nimport { mul } from './mul';\nimport { ones } from './ones';\nimport { op } from './operation';\nimport { reshape } from './reshape';\nimport { scalar } from './scalar';\nimport { sum } from './sum';\n/**\n * Computes the mean of elements across dimensions of a `tf.Tensor`.\n *\n * Reduces `x` along the dimensions given in `axis`. Unless `keepDims` is\n * true, the rank of the `tf.Tensor` is reduced by 1 for each entry in `axis`.\n * If `keepDims` is true, the reduced dimensions are retained with length 1.\n * If `axis` has no entries, all dimensions are reduced, and a `tf.Tensor` with\n * a single element is returned.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3]);\n *\n * x.mean().print();  // or tf.mean(a)\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * const axis = 1;\n * x.mean(axis).print();  // or tf.mean(x, axis)\n * ```\n *\n * @param x The input tensor.\n * @param axis The dimension(s) to reduce. By default it reduces\n *     all dimensions.\n * @param keepDims If true, retains reduced dimensions with size 1.\n */\n\n/** @doc {heading: 'Operations', subheading: 'Reduction'} */\n\nfunction mean_(x, axis = null, keepDims = false) {\n  const $x = convertToTensor(x, 'x', 'mean');\n  const axes = parseAxisParam(axis, $x.shape);\n  const shapes = computeOutAndReduceShapes($x.shape, axes);\n  const reduceShape = shapes[1];\n  const reduceSize = sizeFromShape(reduceShape); // Use a custom gradient to bypass 2 gradient backprops since mean is used\n  // extremely often.\n\n  const customOp = customGrad(x => {\n    const reduceSizeScalar = scalar(reduceSize); // Cast if needed.\n\n    const xReduce = reduceSizeScalar.dtype === x.dtype ? x : cast(x, reduceSizeScalar.dtype);\n    const res = div(xReduce, reduceSizeScalar);\n    const value = sum(res, axis, keepDims);\n\n    const gradFunc = dy => {\n      const expandedDyShape = x.shape.slice();\n      axes.forEach(axis => {\n        expandedDyShape[axis] = 1;\n      });\n      const expandedDy = reshape(dy, expandedDyShape);\n      const derX = div(mul(expandedDy, ones(x.shape, 'float32')), reduceSize);\n      return derX;\n    };\n\n    return {\n      value,\n      gradFunc\n    };\n  });\n  return customOp($x);\n}\n\nexport const mean = op({\n  mean_\n});","map":null,"metadata":{},"sourceType":"module"}