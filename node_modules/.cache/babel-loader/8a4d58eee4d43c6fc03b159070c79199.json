{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { BroadcastTo } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { clone } from './clone';\nimport { op } from './operation';\nimport { reshape } from './reshape';\n/**\n * Broadcast an array to a compatible shape NumPy-style.\n *\n * The tensor's shape is compared to the broadcast shape from end to beginning.\n * Ones are prepended to the tensor's shape until is has the same length as\n * the broadcast shape. If input.shape[i]==shape[i], the (i+1)-th axis is\n * already broadcast-compatible. If input.shape[i]==1 and shape[i]==N, then\n * the input tensor is tiled N times along that axis (using tf.tile).\n *\n * @param input The tensor that is to be broadcasted.\n * @param shape The input is to be broadcast to this shape.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Transformations'} */\n\nfunction broadcastTo_(x, shape) {\n  let input = convertToTensor(x, 'broadcastTo', 'x');\n  const xShape = input.shape;\n\n  if (shape.some(d => !(d > 0) || d % 1 !== 0)) {\n    throw new Error(\"broadcastTo(): Invalid broadcast shape [\".concat(shape, \"].\"));\n  }\n\n  if (shape.length < input.rank) {\n    throw new Error(\"broadcastTo(): shape.length=\".concat(shape.length, \" < input.rank=\").concat(input.rank, \".\"));\n  }\n\n  if (shape.length > input.rank) {\n    const newShape = input.shape.slice();\n\n    while (newShape.length < shape.length) {\n      newShape.unshift(1);\n    }\n\n    input = reshape(input, newShape);\n  }\n\n  const inputShape = input.shape;\n  const reps = Array.from(shape);\n\n  for (let i = shape.length - 1; i >= 0; i--) {\n    if (inputShape[i] === shape[i]) {\n      reps[i] = 1;\n    } else if (input.shape[i] !== 1) {\n      throw new Error(\"broadcastTo(): [\".concat(xShape, \"] cannot be broadcast to [\").concat(shape, \"].\"));\n    }\n  }\n\n  const axes = reps.map((n, i) => n > 1 ? i : -1).filter(i => i >= 0);\n\n  if (axes.length === 0) {\n    return clone(input);\n  }\n\n  const forward = backend => backend.tile(input, reps);\n\n  const inputs = {\n    x: input\n  };\n  const attrs = {\n    shape,\n    inputShape\n  };\n  return ENGINE.runKernelFunc(forward, inputs, null\n  /* grad */\n  , BroadcastTo, attrs);\n}\n\nexport const broadcastTo = op({\n  broadcastTo_\n});","map":null,"metadata":{},"sourceType":"module"}