{"ast":null,"code":"import _slicedToArray from \"/home/victor/COVID-19-Coding-Fest/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { DepthwiseConv2dNative } from '../kernel_names';\nimport * as conv_util from '../ops/conv_util';\nimport { depthwiseConv2dNativeBackpropFilter } from '../ops/depthwise_conv2d_native_backprop_filter';\nimport { depthwiseConv2dNativeBackpropInput } from '../ops/depthwise_conv2d_native_backprop_input';\nimport * as util from '../util';\nexport const depthwiseConv2dNativeGradConfig = {\n  kernelName: DepthwiseConv2dNative,\n  inputsToSave: ['x', 'filter'],\n  gradFunc: (dy, saved, attrs) => {\n    const dilations = attrs.dilations,\n          strides = attrs.strides,\n          pad = attrs.pad,\n          dimRoundingMode = attrs.dimRoundingMode;\n    const $dilations = dilations == null ? [1, 1] : dilations;\n    util.assert(conv_util.tupleValuesAreOne($dilations), () => 'Error in gradient of depthwiseConv2dNative: dilation rates ' + \"greater than 1 are not yet supported. Got dilations \" + \"'\".concat($dilations, \"'\"));\n\n    const _saved = _slicedToArray(saved, 2),\n          x = _saved[0],\n          filter = _saved[1];\n\n    util.assert(x.rank === 4, () => \"Error in gradient of depthwiseConv2dNative: input must be \" + \"rank 4, but got rank \".concat(x.rank, \".\"));\n    util.assert(filter.rank === 4, () => \"Error in gradient of depthwiseConv2dNative: filter must be \" + \"rank 4, but got rank \".concat(filter.rank, \".\"));\n    util.assert(x.shape[3] === filter.shape[2], () => \"Error in gradient of depthwiseConv2d: number of input \" + \"channels (\".concat(x.shape[3], \") must match the inChannels dimension \") + \"in filter \".concat(filter.shape[2], \".\"));\n    util.assert(conv_util.eitherStridesOrDilationsAreOne(strides, $dilations), () => 'Error in gradient of depthwiseConv2d: Either strides or ' + \"dilations must be  1. Got strides \".concat(strides, \" and dilations \") + \"'\".concat($dilations, \"'.\"));\n\n    if (dimRoundingMode != null) {\n      util.assert(util.isInt(pad), () => \"Error in depthwiseConv2d: pad must be an integer when using, \" + \"dimRoundingMode \".concat(dimRoundingMode, \" but got pad \").concat(pad, \".\"));\n    }\n\n    const convInfo = conv_util.computeConv2DInfo(x.shape, filter.shape, strides, $dilations, pad, dimRoundingMode, true\n    /* depthwise */\n    );\n    return {\n      x: () => depthwiseConv2dNativeBackpropInput(x.shape, dy, filter, convInfo),\n      filter: () => depthwiseConv2dNativeBackpropFilter(x, dy, filter.shape, convInfo)\n    };\n  }\n};","map":null,"metadata":{},"sourceType":"module"}