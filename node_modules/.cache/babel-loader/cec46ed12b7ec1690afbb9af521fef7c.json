{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { browser, env, image, tensor1d, tensor2d, tidy, util } from '@tensorflow/tfjs-core';\nimport { LazyIterator } from './lazy_iterator';\n/**\n * Provide a stream of image tensors from webcam video stream. Only works in\n * browser environment.\n */\n\nexport class WebcamIterator extends LazyIterator {\n  constructor(webcamVideoElement, webcamConfig) {\n    super();\n    this.webcamVideoElement = webcamVideoElement;\n    this.webcamConfig = webcamConfig;\n    this.isClosed = true;\n    this.resize = false;\n\n    if (this.needToResize()) {\n      this.resize = true;\n      this.cropSize = [this.webcamConfig.resizeHeight, this.webcamConfig.resizeWidth];\n      this.cropBoxInd = tensor1d([0], 'int32');\n\n      if (this.webcamConfig.centerCrop) {\n        // Calculate the box based on resizing shape.\n        const widthCroppingRatio = this.webcamConfig.resizeWidth * 1.0 / this.webcamVideoElement.width;\n        const heightCroppingRatio = this.webcamConfig.resizeHeight * 1.0 / this.webcamVideoElement.height;\n        const widthCropStart = (1 - widthCroppingRatio) / 2;\n        const heightCropStart = (1 - heightCroppingRatio) / 2;\n        const widthCropEnd = widthCropStart + widthCroppingRatio;\n        const heightCropEnd = heightCroppingRatio + heightCropStart;\n        this.cropBox = tensor2d([heightCropStart, widthCropStart, heightCropEnd, widthCropEnd], [1, 4]);\n      } else {\n        this.cropBox = tensor2d([0, 0, 1, 1], [1, 4]);\n      }\n    }\n  }\n\n  summary() {\n    return \"webcam\";\n  } // Construct a WebcamIterator and start it's video stream.\n\n\n  static async create(webcamVideoElement, webcamConfig = {}) {\n    if (env().get('IS_NODE')) {\n      throw new Error('tf.data.webcam is only supported in browser environment.');\n    }\n\n    if (!webcamVideoElement) {\n      // If webcam video element is not provided, create a hidden video element\n      // with provided width and height.\n      webcamVideoElement = document.createElement('video');\n\n      if (!webcamConfig.resizeWidth || !webcamConfig.resizeHeight) {\n        throw new Error('Please provide webcam video element, or resizeWidth and ' + 'resizeHeight to create a hidden video element.');\n      }\n\n      webcamVideoElement.width = webcamConfig.resizeWidth;\n      webcamVideoElement.height = webcamConfig.resizeHeight;\n    }\n\n    const webcamIterator = new WebcamIterator(webcamVideoElement, webcamConfig); // Call async function to initialize the video stream.\n\n    await webcamIterator.start();\n    return webcamIterator;\n  } // Async function to start video stream.\n\n\n  async start() {\n    if (this.webcamConfig.facingMode) {\n      util.assert(this.webcamConfig.facingMode === 'user' || this.webcamConfig.facingMode === 'environment', () => \"Invalid webcam facing mode: \".concat(this.webcamConfig.facingMode, \". \") + \"Please provide 'user' or 'environment'\");\n    }\n\n    try {\n      this.stream = await navigator.mediaDevices.getUserMedia({\n        video: {\n          deviceId: this.webcamConfig.deviceId,\n          facingMode: this.webcamConfig.facingMode ? this.webcamConfig.facingMode : 'user',\n          width: this.webcamVideoElement.width,\n          height: this.webcamVideoElement.height\n        }\n      });\n    } catch (e) {\n      // Modify the error message but leave the stack trace intact\n      e.message = \"Error thrown while initializing video stream: \".concat(e.message);\n      throw e;\n    }\n\n    if (!this.stream) {\n      throw new Error('Could not obtain video from webcam.');\n    } // Older browsers may not have srcObject\n\n\n    try {\n      this.webcamVideoElement.srcObject = this.stream;\n    } catch (error) {\n      console.log(error);\n      this.webcamVideoElement.src = window.URL.createObjectURL(this.stream);\n    } // Start the webcam video stream\n\n\n    this.webcamVideoElement.play();\n    this.isClosed = false;\n    return new Promise(resolve => {\n      // Add event listener to make sure the webcam has been fully initialized.\n      this.webcamVideoElement.onloadedmetadata = () => {\n        resolve();\n      };\n    });\n  }\n\n  async next() {\n    if (this.isClosed) {\n      return {\n        value: null,\n        done: true\n      };\n    }\n\n    let img;\n\n    try {\n      img = browser.fromPixels(this.webcamVideoElement);\n    } catch (e) {\n      throw new Error(\"Error thrown converting video to pixels: \".concat(JSON.stringify(e)));\n    }\n\n    if (this.resize) {\n      try {\n        return {\n          value: this.cropAndResizeFrame(img),\n          done: false\n        };\n      } catch (e) {\n        throw new Error(\"Error thrown cropping the video: \".concat(e.message));\n      } finally {\n        img.dispose();\n      }\n    } else {\n      return {\n        value: img,\n        done: false\n      };\n    }\n  }\n\n  needToResize() {\n    // If resizeWidth and resizeHeight are provided, and different from the\n    // width and height of original HTMLVideoElement, then resizing and cropping\n    // is required.\n    if (this.webcamConfig.resizeWidth && this.webcamConfig.resizeHeight && (this.webcamVideoElement.width !== this.webcamConfig.resizeWidth || this.webcamVideoElement.height !== this.webcamConfig.resizeHeight)) {\n      return true;\n    }\n\n    return false;\n  } // Cropping and resizing each frame based on config\n\n\n  cropAndResizeFrame(img) {\n    return tidy(() => {\n      const expandedImage = img.toFloat().expandDims(0);\n      let resizedImage;\n      resizedImage = image.cropAndResize(expandedImage, this.cropBox, this.cropBoxInd, this.cropSize, 'bilinear'); // Extract image from batch cropping.\n\n      const shape = resizedImage.shape;\n      return resizedImage.reshape(shape.slice(1));\n    });\n  } // Capture one frame from the video stream, and extract the value from\n  // iterator.next() result.\n\n\n  async capture() {\n    return (await this.next()).value;\n  } // Stop the video stream and pause webcam iterator.\n\n\n  stop() {\n    const tracks = this.stream.getTracks();\n    tracks.forEach(track => track.stop());\n\n    try {\n      this.webcamVideoElement.srcObject = null;\n    } catch (error) {\n      console.log(error);\n      this.webcamVideoElement.src = null;\n    }\n\n    this.isClosed = true;\n  } // Override toArray() function to prevent collecting.\n\n\n  toArray() {\n    throw new Error('Can not convert infinite video stream to array.');\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}