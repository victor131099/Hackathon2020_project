{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from '../util';\nexport function assertParamsValid(input, begin, size) {\n  util.assert(input.rank === begin.length, () => \"Error in slice\".concat(input.rank, \"D: Length of begin \").concat(begin, \" must \") + \"match the rank of the array (\".concat(input.rank, \").\"));\n  util.assert(input.rank === size.length, () => \"Error in slice\".concat(input.rank, \"D: Length of size \").concat(size, \" must \") + \"match the rank of the array (\".concat(input.rank, \").\"));\n\n  for (let i = 0; i < input.rank; ++i) {\n    util.assert(begin[i] + size[i] <= input.shape[i], () => \"Error in slice\".concat(input.rank, \"D: begin[\").concat(i, \"] + size[\").concat(i, \"] \") + \"(\".concat(begin[i] + size[i], \") would overflow input.shape[\").concat(i, \"] (\").concat(input.shape[i], \")\"));\n  }\n}\n/** Converts a binary mask to an array of axes. Used in stridedSlice(). */\n\nexport function maskToAxes(mask) {\n  const axes = [];\n  let axis = 0;\n\n  while (mask > 0) {\n    if (mask & 1) {\n      axes.push(axis);\n    }\n\n    mask /= 2;\n    axis++;\n  }\n\n  return axes;\n}\n/** Computes the output shape given the strided slice params. */\n\nexport function computeOutShape(begin, end, strides) {\n  const size = [];\n\n  for (let axis = 0; axis < begin.length; axis++) {\n    size[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);\n  }\n\n  return size;\n} // Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stride value. Otherwise, insert.\n\nexport function stridesWithElidedDims(strides, ellipsisInsertionIndex, numElidedAxes, inputShape) {\n  const newStrides = [...strides];\n\n  for (let i = newStrides.length; i < inputShape.length; i++) {\n    newStrides.push(1);\n  }\n\n  for (let i = 0; i < numElidedAxes; i++) {\n    if (i === 0) {\n      newStrides[ellipsisInsertionIndex] = 1;\n    } else {\n      newStrides.splice(ellipsisInsertionIndex, 0\n      /* num elements to delete */\n      , 1\n      /* element to add */\n      );\n      newStrides.pop();\n    }\n  }\n\n  return newStrides;\n}\n\nfunction unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, normalizedAxis) {\n  if (normalizedAxis <= ellipsisInsertionIndex) {\n    return normalizedAxis;\n  }\n\n  return normalizedAxis - (numElidedAxes - 1);\n}\n\nfunction getElidedAxes(numElidedAxes, ellipsisInsertionIndex) {\n  const elidedAxes = [];\n\n  for (let i = 0; i < numElidedAxes; i++) {\n    elidedAxes.push(ellipsisInsertionIndex + i);\n  }\n\n  return elidedAxes;\n} // Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current start value. Otherwise, insert.\n\n\nexport function startIndicesWithElidedDims(beginMask, ellipsisInsertionIndex, numElidedAxes, originalBegin, inputShape) {\n  const newIndices = [...inputShape];\n  const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n\n  for (let axis = 0; axis < newIndices.length; axis++) {\n    if (elidedAxes.indexOf(axis) > -1) {\n      newIndices[axis] = 0;\n    } else {\n      const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n      let originalValue = originalBegin[originalAxis];\n\n      if (beginMask & 1 << originalAxis) {\n        originalValue = 0;\n      }\n\n      newIndices[axis] = originalValue;\n    }\n  }\n\n  return newIndices;\n} // Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stop value. Otherwise, insert.\n\nexport function stopIndicesWithElidedDims(endMask, ellipsisInsertionIndex, numElidedAxes, originalEnd, inputShape) {\n  const newIndices = [...inputShape];\n  const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n\n  for (let axis = 0; axis < newIndices.length; axis++) {\n    if (elidedAxes.indexOf(axis) > -1) {\n      newIndices[axis] = Number.MAX_SAFE_INTEGER;\n    } else {\n      const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n      let originalValue = originalEnd[originalAxis];\n\n      if (endMask & 1 << originalAxis) {\n        originalValue = Number.MAX_SAFE_INTEGER;\n      }\n\n      newIndices[axis] = originalValue;\n    }\n  }\n\n  for (let i = 0; i < newIndices.length; i++) {\n    // Handle negative indices\n    const axisSize = inputShape[i];\n\n    if (newIndices[i] < 0) {\n      newIndices[i] += axisSize;\n    }\n\n    newIndices[i] = util.clamp(0, newIndices[i], inputShape[i]);\n  }\n\n  return newIndices;\n}\nexport function stridesForAxis(strides, axis, ellipsisMask) {\n  let stride = strides[axis];\n\n  if (ellipsisMask & 1 << axis || stride == null) {\n    stride = 1;\n  }\n\n  return stride;\n}\nexport function startForAxis(beginMask, startIndices, strides, inputShape, axis, ellipsisMask) {\n  // Begin with the specified index\n  let start = startIndices[axis];\n  const stride = strides[axis] || 1; // Check the axis bit from right of masked axes, or the begin index is not set\n  // for the axis.\n\n  if (beginMask & 1 << axis || ellipsisMask & 1 << axis || start == null) {\n    if (stride > 0) {\n      // Forward iteration - use the first element. These values will get\n      // clamped below (Note: We could have set them to 0 and axis_size-1, but\n      // use lowest() and max() to maintain symmetry with StopForAxis())\n      start = Number.MIN_SAFE_INTEGER;\n    } else {\n      // Backward iteration - use the last element.\n      start = Number.MAX_SAFE_INTEGER;\n    }\n  } // Handle negative indices\n\n\n  const axisSize = inputShape[axis];\n\n  if (start < 0) {\n    start += axisSize;\n  } // Clamping\n\n\n  start = util.clamp(0, start, axisSize - 1);\n  return start;\n}\nexport function stopForAxis(endMask, stopIndices, strides, inputShape, axis, ellipsisMask) {\n  // Begin with the specified index\n  let stop = stopIndices[axis];\n  const stride = strides[axis] || 1; // Check the axis bit from right of masked axes, or if the stop index is not\n  // set for this axis.\n\n  if (endMask & 1 << axis || ellipsisMask & 1 << axis || stop == null) {\n    if (stride > 0) {\n      // Forward iteration - use the last element. These values will get\n      // clamped below\n      stop = Number.MAX_SAFE_INTEGER;\n    } else {\n      // Backward iteration - use the first element.\n      stop = Number.MIN_SAFE_INTEGER;\n    }\n  } // Handle negative indices\n\n\n  const axisSize = inputShape[axis];\n\n  if (stop < 0) {\n    stop += axisSize;\n  } // Clamping\n  // Because the end index points one past the last element, we need slightly\n  // different clamping ranges depending on the direction.\n\n\n  if (stride > 0) {\n    // Forward iteration\n    stop = util.clamp(0, stop, axisSize);\n  } else {\n    // Backward iteration\n    stop = util.clamp(-1, stop, axisSize - 1);\n  }\n\n  return stop;\n}\n/**\n * Returns true if the slice occupies a continous set of elements in the\n * 'flat' space.\n */\n\nexport function isSliceContinous(shape, begin, size) {\n  // Index of the first axis that has size > 1.\n  let firstNonOneAxis = size.length;\n\n  for (let i = 0; i < size.length; i++) {\n    if (size[i] > 1) {\n      firstNonOneAxis = i;\n      break;\n    }\n  }\n\n  for (let i = firstNonOneAxis + 1; i < size.length; i++) {\n    if (begin[i] > 0 || size[i] !== shape[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\nexport function computeFlatOffset(begin, strides) {\n  let flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;\n\n  for (let i = 0; i < begin.length - 1; i++) {\n    flatOffset += begin[i] * strides[i];\n  }\n\n  return flatOffset;\n}\nexport function parseSliceParams(x, begin, size) {\n  // The following logic allows for more ergonomic calls.\n  let begin_;\n\n  if (typeof begin === 'number') {\n    begin_ = [begin, ...new Array(x.rank - 1).fill(0)];\n  } else if (begin.length < x.rank) {\n    begin_ = begin.concat(new Array(x.rank - begin.length).fill(0));\n  } else {\n    begin_ = begin.slice();\n  }\n\n  begin_.forEach(d => {\n    util.assert(d !== -1, () => 'slice() does not support negative begin indexing.');\n  });\n  let size_;\n\n  if (size == null) {\n    size_ = new Array(x.rank).fill(-1);\n  } else if (typeof size === 'number') {\n    size_ = [size, ...new Array(x.rank - 1).fill(-1)];\n  } else if (size.length < x.rank) {\n    size_ = size.concat(new Array(x.rank - size.length).fill(-1));\n  } else {\n    size_ = size;\n  }\n\n  size_ = size_.map((d, i) => {\n    if (d >= 0) {\n      return d;\n    } else {\n      util.assert(d === -1, () => \"Negative size values should be exactly -1 but got \" + \"\".concat(d, \" for the slice() size at index \").concat(i, \".\"));\n      return x.shape[i] - begin_[i];\n    }\n  });\n  return [begin_, size_];\n}","map":null,"metadata":{},"sourceType":"module"}