{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { computeStrides, isString, rightPad, sizeFromShape } from './util'; // Maximum number of values before we decide to show ellipsis.\n\nconst FORMAT_LIMIT_NUM_VALS = 20; // Number of first and last values to show when displaying a, b,...,y, z.\n\nconst FORMAT_NUM_FIRST_LAST_VALS = 3; // Number of significant digits to show.\n\nconst FORMAT_NUM_SIG_DIGITS = 7;\nexport function tensorToString(vals, shape, dtype, verbose) {\n  const strides = computeStrides(shape);\n  const padPerCol = computeMaxSizePerColumn(vals, shape, dtype, strides);\n  const rank = shape.length;\n  const valsLines = subTensorToString(vals, shape, dtype, strides, padPerCol);\n  const lines = ['Tensor'];\n\n  if (verbose) {\n    lines.push(\"  dtype: \".concat(dtype));\n    lines.push(\"  rank: \".concat(rank));\n    lines.push(\"  shape: [\".concat(shape, \"]\"));\n    lines.push(\"  values:\");\n  }\n\n  lines.push(valsLines.map(l => '    ' + l).join('\\n'));\n  return lines.join('\\n');\n}\n\nfunction computeMaxSizePerColumn(vals, shape, dtype, strides) {\n  const n = sizeFromShape(shape);\n  const numCols = strides[strides.length - 1];\n  const padPerCol = new Array(numCols).fill(0);\n  const rank = shape.length;\n  const valuesOrTuples = dtype === 'complex64' ? createComplexTuples(vals) : vals;\n\n  if (rank > 1) {\n    for (let row = 0; row < n / numCols; row++) {\n      const offset = row * numCols;\n\n      for (let j = 0; j < numCols; j++) {\n        padPerCol[j] = Math.max(padPerCol[j], valToString(valuesOrTuples[offset + j], 0, dtype).length);\n      }\n    }\n  }\n\n  return padPerCol;\n}\n\nfunction valToString(val, pad, dtype) {\n  let valStr;\n\n  if (Array.isArray(val)) {\n    valStr = \"\".concat(parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS)), \" + \") + \"\".concat(parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS)), \"j\");\n  } else if (isString(val)) {\n    valStr = \"'\".concat(val, \"'\");\n  } else if (dtype === 'bool') {\n    valStr = boolNumToString(val);\n  } else {\n    valStr = parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString();\n  }\n\n  return rightPad(valStr, pad);\n}\n\nfunction boolNumToString(v) {\n  return v === 0 ? 'false' : 'true';\n}\n\nfunction subTensorToString(vals, shape, dtype, strides, padPerCol, isLast = true) {\n  const storagePerElement = dtype === 'complex64' ? 2 : 1;\n  const size = shape[0];\n  const rank = shape.length;\n\n  if (rank === 0) {\n    if (dtype === 'complex64') {\n      const complexTuple = createComplexTuples(vals);\n      return [valToString(complexTuple[0], 0, dtype)];\n    }\n\n    if (dtype === 'bool') {\n      return [boolNumToString(vals[0])];\n    }\n\n    return [vals[0].toString()];\n  }\n\n  if (rank === 1) {\n    if (size > FORMAT_LIMIT_NUM_VALS) {\n      const firstValsSize = FORMAT_NUM_FIRST_LAST_VALS * storagePerElement;\n      let firstVals = Array.from(vals.slice(0, firstValsSize));\n      let lastVals = Array.from(vals.slice((size - FORMAT_NUM_FIRST_LAST_VALS) * storagePerElement, size * storagePerElement));\n\n      if (dtype === 'complex64') {\n        firstVals = createComplexTuples(firstVals);\n        lastVals = createComplexTuples(lastVals);\n      }\n\n      return ['[' + firstVals.map((x, i) => valToString(x, padPerCol[i], dtype)).join(', ') + ', ..., ' + lastVals.map((x, i) => valToString(x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS + i], dtype)).join(', ') + ']'];\n    }\n\n    const displayVals = dtype === 'complex64' ? createComplexTuples(vals) : Array.from(vals);\n    return ['[' + displayVals.map((x, i) => valToString(x, padPerCol[i], dtype)).join(', ') + ']'];\n  } // The array is rank 2 or more.\n\n\n  const subshape = shape.slice(1);\n  const substrides = strides.slice(1);\n  const stride = strides[0] * storagePerElement;\n  const lines = [];\n\n  if (size > FORMAT_LIMIT_NUM_VALS) {\n    for (let i = 0; i < FORMAT_NUM_FIRST_LAST_VALS; i++) {\n      const start = i * stride;\n      const end = start + stride;\n      lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, false\n      /* isLast */\n      ));\n    }\n\n    lines.push('...');\n\n    for (let i = size - FORMAT_NUM_FIRST_LAST_VALS; i < size; i++) {\n      const start = i * stride;\n      const end = start + stride;\n      lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1\n      /* isLast */\n      ));\n    }\n  } else {\n    for (let i = 0; i < size; i++) {\n      const start = i * stride;\n      const end = start + stride;\n      lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1\n      /* isLast */\n      ));\n    }\n  }\n\n  const sep = rank === 2 ? ',' : '';\n  lines[0] = '[' + lines[0] + sep;\n\n  for (let i = 1; i < lines.length - 1; i++) {\n    lines[i] = ' ' + lines[i] + sep;\n  }\n\n  let newLineSep = ',\\n';\n\n  for (let i = 2; i < rank; i++) {\n    newLineSep += '\\n';\n  }\n\n  lines[lines.length - 1] = ' ' + lines[lines.length - 1] + ']' + (isLast ? '' : newLineSep);\n  return lines;\n}\n\nfunction createComplexTuples(vals) {\n  const complexTuples = [];\n\n  for (let i = 0; i < vals.length; i += 2) {\n    complexTuples.push([vals[i], vals[i + 1]]);\n  }\n\n  return complexTuples;\n}","map":null,"metadata":{},"sourceType":"module"}