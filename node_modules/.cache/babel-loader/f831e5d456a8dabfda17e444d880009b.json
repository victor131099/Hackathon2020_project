{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/* original source: keras/regularizers.py */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { abs, add, serialization, sum, tidy, zeros } from '@tensorflow/tfjs-core';\nimport * as K from './backend/tfjs_backend';\nimport { deserializeKerasObject, serializeKerasObject } from './utils/generic_utils';\n\nfunction assertObjectArgs(args) {\n  if (args != null && typeof args !== 'object') {\n    throw new Error(\"Argument to L1L2 regularizer's constructor is expected to be an \" + \"object, but received: \".concat(args));\n  }\n}\n/**\n * Regularizer base class.\n */\n\n\nexport class Regularizer extends serialization.Serializable {}\nexport class L1L2 extends Regularizer {\n  constructor(args) {\n    super();\n    assertObjectArgs(args);\n    this.l1 = args == null || args.l1 == null ? 0.01 : args.l1;\n    this.l2 = args == null || args.l2 == null ? 0.01 : args.l2;\n    this.hasL1 = this.l1 !== 0;\n    this.hasL2 = this.l2 !== 0;\n  }\n  /**\n   * Porting note: Renamed from __call__.\n   * @param x Variable of which to calculate the regularization score.\n   */\n\n\n  apply(x) {\n    return tidy(() => {\n      let regularization = zeros([1]);\n\n      if (this.hasL1) {\n        regularization = add(regularization, sum(tfc.mul(this.l1, abs(x))));\n      }\n\n      if (this.hasL2) {\n        regularization = add(regularization, sum(tfc.mul(this.l2, K.square(x))));\n      }\n\n      return regularization.asScalar();\n    });\n  }\n\n  getConfig() {\n    return {\n      'l1': this.l1,\n      'l2': this.l2\n    };\n  }\n  /** @nocollapse */\n\n\n  static fromConfig(cls, config) {\n    return new cls({\n      l1: config['l1'],\n      l2: config['l2']\n    });\n  }\n\n}\n/** @nocollapse */\n\nL1L2.className = 'L1L2';\nserialization.registerClass(L1L2);\nexport function l1(args) {\n  assertObjectArgs(args);\n  return new L1L2({\n    l1: args != null ? args.l1 : null,\n    l2: 0\n  });\n}\nexport function l2(args) {\n  assertObjectArgs(args);\n  return new L1L2({\n    l2: args != null ? args.l2 : null,\n    l1: 0\n  });\n} // Maps the JavaScript-like identifier keys to the corresponding keras symbols.\n\nexport const REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP = {\n  'l1l2': 'L1L2'\n};\nexport function serializeRegularizer(constraint) {\n  return serializeKerasObject(constraint);\n}\nexport function deserializeRegularizer(config, customObjects = {}) {\n  return deserializeKerasObject(config, serialization.SerializationMap.getMap().classNameMap, customObjects, 'regularizer');\n}\nexport function getRegularizer(identifier) {\n  if (identifier == null) {\n    return null;\n  }\n\n  if (typeof identifier === 'string') {\n    const className = identifier in REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP ? REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier] : identifier;\n    const config = {\n      className,\n      config: {}\n    };\n    return deserializeRegularizer(config);\n  } else if (identifier instanceof Regularizer) {\n    return identifier;\n  } else {\n    return deserializeRegularizer(identifier);\n  }\n}","map":null,"metadata":{},"sourceType":"module"}